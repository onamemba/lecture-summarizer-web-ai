{"ast":null,"code":"/**!\r\n * audioMotion-analyzer\r\n * High-resolution real-time graphic audio spectrum analyzer JS module\r\n *\r\n * @version 4.5.0\r\n * @author  Henrique Avila Vianna <hvianna@gmail.com> <https://henriquevianna.com>\r\n * @license AGPL-3.0-or-later\r\n */\n\nconst VERSION = '4.5.0';\n\n// internal constants\nconst PI = Math.PI,\n  TAU = 2 * PI,\n  HALF_PI = PI / 2,\n  C_1 = 8.17579892; // frequency for C -1\n\nconst CANVAS_BACKGROUND_COLOR = '#000',\n  CHANNEL_COMBINED = 'dual-combined',\n  CHANNEL_HORIZONTAL = 'dual-horizontal',\n  CHANNEL_SINGLE = 'single',\n  CHANNEL_VERTICAL = 'dual-vertical',\n  COLOR_BAR_INDEX = 'bar-index',\n  COLOR_BAR_LEVEL = 'bar-level',\n  COLOR_GRADIENT = 'gradient',\n  DEBOUNCE_TIMEOUT = 60,\n  EVENT_CLICK = 'click',\n  EVENT_FULLSCREENCHANGE = 'fullscreenchange',\n  EVENT_RESIZE = 'resize',\n  GRADIENT_DEFAULT_BGCOLOR = '#111',\n  FILTER_NONE = '',\n  FILTER_A = 'A',\n  FILTER_B = 'B',\n  FILTER_C = 'C',\n  FILTER_D = 'D',\n  FILTER_468 = '468',\n  FONT_FAMILY = 'sans-serif',\n  FPS_COLOR = '#0f0',\n  LEDS_UNLIT_COLOR = '#7f7f7f22',\n  MODE_GRAPH = 10,\n  REASON_CREATE = 'create',\n  REASON_FSCHANGE = 'fschange',\n  REASON_LORES = 'lores',\n  REASON_RESIZE = EVENT_RESIZE,\n  REASON_USER = 'user',\n  SCALEX_BACKGROUND_COLOR = '#000c',\n  SCALEX_LABEL_COLOR = '#fff',\n  SCALEX_HIGHLIGHT_COLOR = '#4f4',\n  SCALEY_LABEL_COLOR = '#888',\n  SCALEY_MIDLINE_COLOR = '#555',\n  SCALE_BARK = 'bark',\n  SCALE_LINEAR = 'linear',\n  SCALE_LOG = 'log',\n  SCALE_MEL = 'mel';\n\n// built-in gradients\nconst PRISM = ['#a35', '#c66', '#e94', '#ed0', '#9d5', '#4d8', '#2cb', '#0bc', '#09c', '#36b'],\n  GRADIENTS = [['classic', {\n    colorStops: ['red', {\n      color: 'yellow',\n      level: .85,\n      pos: .6\n    }, {\n      color: 'lime',\n      level: .475\n    }]\n  }], ['prism', {\n    colorStops: PRISM\n  }], ['rainbow', {\n    dir: 'h',\n    colorStops: ['#817', ...PRISM, '#639']\n  }], ['orangered', {\n    bgColor: '#3e2f29',\n    colorStops: ['OrangeRed']\n  }], ['steelblue', {\n    bgColor: '#222c35',\n    colorStops: ['SteelBlue']\n  }]];\n\n// settings defaults\nconst DEFAULT_SETTINGS = {\n  alphaBars: false,\n  ansiBands: false,\n  barSpace: 0.1,\n  bgAlpha: 0.7,\n  channelLayout: CHANNEL_SINGLE,\n  colorMode: COLOR_GRADIENT,\n  fadePeaks: false,\n  fftSize: 8192,\n  fillAlpha: 1,\n  frequencyScale: SCALE_LOG,\n  gradient: GRADIENTS[0][0],\n  gravity: 3.8,\n  height: undefined,\n  ledBars: false,\n  linearAmplitude: false,\n  linearBoost: 1,\n  lineWidth: 0,\n  loRes: false,\n  lumiBars: false,\n  maxDecibels: -25,\n  maxFPS: 0,\n  maxFreq: 22000,\n  minDecibels: -85,\n  minFreq: 20,\n  mirror: 0,\n  mode: 0,\n  noteLabels: false,\n  outlineBars: false,\n  overlay: false,\n  peakFadeTime: 750,\n  peakHoldTime: 500,\n  peakLine: false,\n  radial: false,\n  radialInvert: false,\n  radius: 0.3,\n  reflexAlpha: 0.15,\n  reflexBright: 1,\n  reflexFit: true,\n  reflexRatio: 0,\n  roundBars: false,\n  showBgColor: true,\n  showFPS: false,\n  showPeaks: true,\n  showScaleX: true,\n  showScaleY: false,\n  smoothing: 0.5,\n  spinSpeed: 0,\n  splitGradient: false,\n  start: true,\n  trueLeds: false,\n  useCanvas: true,\n  volume: 1,\n  weightingFilter: FILTER_NONE,\n  width: undefined\n};\n\n// custom error messages\nconst ERR_AUDIO_CONTEXT_FAIL = ['ERR_AUDIO_CONTEXT_FAIL', 'Could not create audio context. Web Audio API not supported?'],\n  ERR_INVALID_AUDIO_CONTEXT = ['ERR_INVALID_AUDIO_CONTEXT', 'Provided audio context is not valid'],\n  ERR_UNKNOWN_GRADIENT = ['ERR_UNKNOWN_GRADIENT', 'Unknown gradient'],\n  ERR_FREQUENCY_TOO_LOW = ['ERR_FREQUENCY_TOO_LOW', 'Frequency values must be >= 1'],\n  ERR_INVALID_MODE = ['ERR_INVALID_MODE', 'Invalid mode'],\n  ERR_REFLEX_OUT_OF_RANGE = ['ERR_REFLEX_OUT_OF_RANGE', 'Reflex ratio must be >= 0 and < 1'],\n  ERR_INVALID_AUDIO_SOURCE = ['ERR_INVALID_AUDIO_SOURCE', 'Audio source must be an instance of HTMLMediaElement or AudioNode'],\n  ERR_GRADIENT_INVALID_NAME = ['ERR_GRADIENT_INVALID_NAME', 'Gradient name must be a non-empty string'],\n  ERR_GRADIENT_NOT_AN_OBJECT = ['ERR_GRADIENT_NOT_AN_OBJECT', 'Gradient options must be an object'],\n  ERR_GRADIENT_MISSING_COLOR = ['ERR_GRADIENT_MISSING_COLOR', 'Gradient colorStops must be a non-empty array'];\nclass AudioMotionError extends Error {\n  constructor(error, value) {\n    const [code, message] = error;\n    super(message + (value !== undefined ? `: ${value}` : ''));\n    this.name = 'AudioMotionError';\n    this.code = code;\n  }\n}\n\n// helper function - output deprecation warning message on console\nconst deprecate = (name, alternative) => console.warn(`${name} is deprecated. Use ${alternative} instead.`);\n\n// helper function - check if a given object is empty (also returns `true` on null, undefined or any non-object value)\nconst isEmpty = obj => {\n  for (const p in obj) return false;\n  return true;\n};\n\n// helper function - validate a given value with an array of strings (by default, all lowercase)\n// returns the validated value, or the first element of `list` if `value` is not found in the array\nconst validateFromList = (value, list, modifier = 'toLowerCase') => list[Math.max(0, list.indexOf(('' + value)[modifier]()))];\n\n// helper function - find the Y-coordinate of a point located between two other points, given its X-coordinate\nconst findY = (x1, y1, x2, y2, x) => y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n\n// Polyfill for Array.findLastIndex()\nif (!Array.prototype.findLastIndex) {\n  Array.prototype.findLastIndex = function (callback) {\n    let index = this.length;\n    while (index-- > 0) {\n      if (callback(this[index])) return index;\n    }\n    return -1;\n  };\n}\n\n// AudioMotionAnalyzer class\n\nclass AudioMotionAnalyzer {\n  /**\r\n   * CONSTRUCTOR\r\n   *\r\n   * @param {object} [container] DOM element where to insert the analyzer; if undefined, uses the document body\r\n   * @param {object} [options]\r\n   * @returns {object} AudioMotionAnalyzer object\r\n   */\n  constructor(container, options = {}) {\n    this._ready = false;\n\n    // Initialize internal objects\n    this._aux = {}; // auxiliary variables\n    this._canvasGradients = []; // CanvasGradient objects for channels 0 and 1\n    this._destroyed = false;\n    this._energy = {\n      val: 0,\n      peak: 0,\n      hold: 0\n    };\n    this._flg = {}; // flags\n    this._fps = 0;\n    this._gradients = {}; // registered gradients\n    this._last = 0; // timestamp of last rendered frame\n    this._outNodes = []; // output nodes\n    this._ownContext = false;\n    this._selectedGrads = []; // names of the currently selected gradients for channels 0 and 1\n    this._sources = []; // input nodes\n\n    // Check if options object passed as first argument\n    if (!(container instanceof Element)) {\n      if (isEmpty(options) && !isEmpty(container)) options = container;\n      container = null;\n    }\n    this._ownCanvas = !(options.canvas instanceof HTMLCanvasElement);\n\n    // Create a new canvas or use the one provided by the user\n    const canvas = this._ownCanvas ? document.createElement('canvas') : options.canvas;\n    canvas.style = 'max-width: 100%;';\n    this._ctx = canvas.getContext('2d');\n\n    // Register built-in gradients\n    for (const [name, options] of GRADIENTS) this.registerGradient(name, options);\n\n    // Set container\n    this._container = container || !this._ownCanvas && canvas.parentElement || document.body;\n\n    // Make sure we have minimal width and height dimensions in case of an inline container\n    this._defaultWidth = this._container.clientWidth || 640;\n    this._defaultHeight = this._container.clientHeight || 270;\n\n    // Use audio context provided by user, or create a new one\n\n    let audioCtx;\n    if (options.source && (audioCtx = options.source.context)) {\n      // get audioContext from provided source audioNode\n    } else if (audioCtx = options.audioCtx) {\n      // use audioContext provided by user\n    } else {\n      try {\n        audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n        this._ownContext = true;\n      } catch (err) {\n        throw new AudioMotionError(ERR_AUDIO_CONTEXT_FAIL);\n      }\n    }\n\n    // make sure audioContext is valid\n    if (!audioCtx.createGain) throw new AudioMotionError(ERR_INVALID_AUDIO_CONTEXT);\n\n    /*\r\n    \tConnection routing:\r\n    \t===================\r\n    \t\t\tfor dual channel layouts:                +--->  analyzer[0]  ---+\r\n        \t                                     |                      |\r\n    \t(source) --->  input  --->  splitter  ---+                      +--->  merger  --->  output  ---> (destination)\r\n        \t                                     |                      |\r\n            \t                                 +--->  analyzer[1]  ---+\r\n    \t\t\tfor single channel layout:\r\n    \t\t\t(source) --->  input  ----------------------->  analyzer[0]  --------------------->  output  ---> (destination)\r\n    \t\t*/\n\n    // create the analyzer nodes, channel splitter and merger, and gain nodes for input/output connections\n    const analyzer = this._analyzer = [audioCtx.createAnalyser(), audioCtx.createAnalyser()];\n    const splitter = this._splitter = audioCtx.createChannelSplitter(2);\n    const merger = this._merger = audioCtx.createChannelMerger(2);\n    this._input = audioCtx.createGain();\n    this._output = audioCtx.createGain();\n\n    // connect audio source if provided in the options\n    if (options.source) this.connectInput(options.source);\n\n    // connect splitter -> analyzers\n    for (const i of [0, 1]) splitter.connect(analyzer[i], i);\n\n    // connect merger -> output\n    merger.connect(this._output);\n\n    // connect output -> destination (speakers)\n    if (options.connectSpeakers !== false) this.connectOutput();\n\n    // create auxiliary canvases for the X-axis and radial scale labels\n    for (const ctx of ['_scaleX', '_scaleR']) this[ctx] = document.createElement('canvas').getContext('2d');\n\n    // set fullscreen element (defaults to canvas)\n    this._fsEl = options.fsElement || canvas;\n\n    // Update canvas size on container / window resize and fullscreen events\n\n    // Fullscreen changes are handled quite differently across browsers:\n    // 1. Chromium browsers will trigger a `resize` event followed by a `fullscreenchange`\n    // 2. Firefox triggers the `fullscreenchange` first and then the `resize`\n    // 3. Chrome on Android (TV) won't trigger a `resize` event, only `fullscreenchange`\n    // 4. Safari won't trigger `fullscreenchange` events at all, and on iPadOS the `resize`\n    //    event is triggered **on the window** only (last tested on iPadOS 14)\n\n    // helper function for resize events\n    const onResize = () => {\n      if (!this._fsTimeout) {\n        // delay the resize to prioritize a possible following `fullscreenchange` event\n        this._fsTimeout = window.setTimeout(() => {\n          if (!this._fsChanging) {\n            this._setCanvas(REASON_RESIZE);\n            this._fsTimeout = 0;\n          }\n        }, DEBOUNCE_TIMEOUT);\n      }\n    };\n\n    // if browser supports ResizeObserver, listen for resize on the container\n    if (window.ResizeObserver) {\n      this._observer = new ResizeObserver(onResize);\n      this._observer.observe(this._container);\n    }\n\n    // create an AbortController to remove event listeners on destroy()\n    this._controller = new AbortController();\n    const signal = this._controller.signal;\n\n    // listen for resize events on the window - required for fullscreen on iPadOS\n    window.addEventListener(EVENT_RESIZE, onResize, {\n      signal\n    });\n\n    // listen for fullscreenchange events on the canvas - not available on Safari\n    canvas.addEventListener(EVENT_FULLSCREENCHANGE, () => {\n      // set flag to indicate a fullscreen change in progress\n      this._fsChanging = true;\n\n      // if there is a scheduled resize event, clear it\n      if (this._fsTimeout) window.clearTimeout(this._fsTimeout);\n\n      // update the canvas\n      this._setCanvas(REASON_FSCHANGE);\n\n      // delay clearing the flag to prevent any shortly following resize event\n      this._fsTimeout = window.setTimeout(() => {\n        this._fsChanging = false;\n        this._fsTimeout = 0;\n      }, DEBOUNCE_TIMEOUT);\n    }, {\n      signal\n    });\n\n    // Resume audio context if in suspended state (browsers' autoplay policy)\n    const unlockContext = () => {\n      if (audioCtx.state == 'suspended') audioCtx.resume();\n      window.removeEventListener(EVENT_CLICK, unlockContext);\n    };\n    window.addEventListener(EVENT_CLICK, unlockContext);\n\n    // reset FPS-related variables when window becomes visible (avoid FPS drop due to frames not rendered while hidden)\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState != 'hidden') {\n        this._frames = 0;\n        this._time = performance.now();\n      }\n    }, {\n      signal\n    });\n\n    // Set configuration options and use defaults for any missing properties\n    this._setProps(options, true);\n\n    // Add canvas to the container (only when canvas not provided by user)\n    if (this.useCanvas && this._ownCanvas) this._container.appendChild(canvas);\n\n    // Finish canvas setup\n    this._ready = true;\n    this._setCanvas(REASON_CREATE);\n  }\n\n  /**\r\n   * ==========================================================================\r\n   *\r\n   * PUBLIC PROPERTIES GETTERS AND SETTERS\r\n   *\r\n   * ==========================================================================\r\n   */\n\n  get alphaBars() {\n    return this._alphaBars;\n  }\n  set alphaBars(value) {\n    this._alphaBars = !!value;\n    this._calcBars();\n  }\n  get ansiBands() {\n    return this._ansiBands;\n  }\n  set ansiBands(value) {\n    this._ansiBands = !!value;\n    this._calcBars();\n  }\n  get barSpace() {\n    return this._barSpace;\n  }\n  set barSpace(value) {\n    this._barSpace = +value || 0;\n    this._calcBars();\n  }\n  get channelLayout() {\n    return this._chLayout;\n  }\n  set channelLayout(value) {\n    this._chLayout = validateFromList(value, [CHANNEL_SINGLE, CHANNEL_HORIZONTAL, CHANNEL_VERTICAL, CHANNEL_COMBINED]);\n\n    // update node connections\n    this._input.disconnect();\n    this._input.connect(this._chLayout != CHANNEL_SINGLE ? this._splitter : this._analyzer[0]);\n    this._analyzer[0].disconnect();\n    if (this._outNodes.length)\n      // connect analyzer only if the output is connected to other nodes\n      this._analyzer[0].connect(this._chLayout != CHANNEL_SINGLE ? this._merger : this._output);\n    this._calcBars();\n    this._makeGrad();\n  }\n  get colorMode() {\n    return this._colorMode;\n  }\n  set colorMode(value) {\n    this._colorMode = validateFromList(value, [COLOR_GRADIENT, COLOR_BAR_INDEX, COLOR_BAR_LEVEL]);\n  }\n  get fadePeaks() {\n    return this._fadePeaks;\n  }\n  set fadePeaks(value) {\n    this._fadePeaks = !!value;\n  }\n  get fftSize() {\n    return this._analyzer[0].fftSize;\n  }\n  set fftSize(value) {\n    for (const i of [0, 1]) this._analyzer[i].fftSize = value;\n    const binCount = this._analyzer[0].frequencyBinCount;\n    this._fftData = [new Float32Array(binCount), new Float32Array(binCount)];\n    this._calcBars();\n  }\n  get frequencyScale() {\n    return this._frequencyScale;\n  }\n  set frequencyScale(value) {\n    this._frequencyScale = validateFromList(value, [SCALE_LOG, SCALE_BARK, SCALE_MEL, SCALE_LINEAR]);\n    this._calcBars();\n  }\n  get gradient() {\n    return this._selectedGrads[0];\n  }\n  set gradient(value) {\n    this._setGradient(value);\n  }\n  get gradientLeft() {\n    return this._selectedGrads[0];\n  }\n  set gradientLeft(value) {\n    this._setGradient(value, 0);\n  }\n  get gradientRight() {\n    return this._selectedGrads[1];\n  }\n  set gradientRight(value) {\n    this._setGradient(value, 1);\n  }\n  get gravity() {\n    return this._gravity;\n  }\n  set gravity(value) {\n    this._gravity = value > 0 ? +value : this._gravity || DEFAULT_SETTINGS.gravity;\n  }\n  get height() {\n    return this._height;\n  }\n  set height(h) {\n    this._height = h;\n    this._setCanvas(REASON_USER);\n  }\n  get ledBars() {\n    return this._showLeds;\n  }\n  set ledBars(value) {\n    this._showLeds = !!value;\n    this._calcBars();\n  }\n  get linearAmplitude() {\n    return this._linearAmplitude;\n  }\n  set linearAmplitude(value) {\n    this._linearAmplitude = !!value;\n  }\n  get linearBoost() {\n    return this._linearBoost;\n  }\n  set linearBoost(value) {\n    this._linearBoost = value >= 1 ? +value : 1;\n  }\n  get lineWidth() {\n    return this._lineWidth;\n  }\n  set lineWidth(value) {\n    this._lineWidth = +value || 0;\n  }\n  get loRes() {\n    return this._loRes;\n  }\n  set loRes(value) {\n    this._loRes = !!value;\n    this._setCanvas(REASON_LORES);\n  }\n  get lumiBars() {\n    return this._lumiBars;\n  }\n  set lumiBars(value) {\n    this._lumiBars = !!value;\n    this._calcBars();\n    this._makeGrad();\n  }\n  get maxDecibels() {\n    return this._analyzer[0].maxDecibels;\n  }\n  set maxDecibels(value) {\n    for (const i of [0, 1]) this._analyzer[i].maxDecibels = value;\n  }\n  get maxFPS() {\n    return this._maxFPS;\n  }\n  set maxFPS(value) {\n    this._maxFPS = value < 0 ? 0 : +value || 0;\n  }\n  get maxFreq() {\n    return this._maxFreq;\n  }\n  set maxFreq(value) {\n    if (value < 1) throw new AudioMotionError(ERR_FREQUENCY_TOO_LOW);else {\n      this._maxFreq = Math.min(value, this.audioCtx.sampleRate / 2);\n      this._calcBars();\n    }\n  }\n  get minDecibels() {\n    return this._analyzer[0].minDecibels;\n  }\n  set minDecibels(value) {\n    for (const i of [0, 1]) this._analyzer[i].minDecibels = value;\n  }\n  get minFreq() {\n    return this._minFreq;\n  }\n  set minFreq(value) {\n    if (value < 1) throw new AudioMotionError(ERR_FREQUENCY_TOO_LOW);else {\n      this._minFreq = +value;\n      this._calcBars();\n    }\n  }\n  get mirror() {\n    return this._mirror;\n  }\n  set mirror(value) {\n    this._mirror = Math.sign(value) | 0; // ensure only -1, 0 or 1\n    this._calcBars();\n    this._makeGrad();\n  }\n  get mode() {\n    return this._mode;\n  }\n  set mode(value) {\n    const mode = value | 0;\n    if (mode >= 0 && mode <= 10 && mode != 9) {\n      this._mode = mode;\n      this._calcBars();\n      this._makeGrad();\n    } else throw new AudioMotionError(ERR_INVALID_MODE, value);\n  }\n  get noteLabels() {\n    return this._noteLabels;\n  }\n  set noteLabels(value) {\n    this._noteLabels = !!value;\n    this._createScales();\n  }\n  get outlineBars() {\n    return this._outlineBars;\n  }\n  set outlineBars(value) {\n    this._outlineBars = !!value;\n    this._calcBars();\n  }\n  get peakFadeTime() {\n    return this._peakFadeTime;\n  }\n  set peakFadeTime(value) {\n    this._peakFadeTime = value >= 0 ? +value : this._peakFadeTime || DEFAULT_SETTINGS.peakFadeTime;\n  }\n  get peakHoldTime() {\n    return this._peakHoldTime;\n  }\n  set peakHoldTime(value) {\n    this._peakHoldTime = +value || 0;\n  }\n  get peakLine() {\n    return this._peakLine;\n  }\n  set peakLine(value) {\n    this._peakLine = !!value;\n  }\n  get radial() {\n    return this._radial;\n  }\n  set radial(value) {\n    this._radial = !!value;\n    this._calcBars();\n    this._makeGrad();\n  }\n  get radialInvert() {\n    return this._radialInvert;\n  }\n  set radialInvert(value) {\n    this._radialInvert = !!value;\n    this._calcBars();\n    this._makeGrad();\n  }\n  get radius() {\n    return this._radius;\n  }\n  set radius(value) {\n    this._radius = +value || 0;\n    this._calcBars();\n    this._makeGrad();\n  }\n  get reflexRatio() {\n    return this._reflexRatio;\n  }\n  set reflexRatio(value) {\n    value = +value || 0;\n    if (value < 0 || value >= 1) throw new AudioMotionError(ERR_REFLEX_OUT_OF_RANGE);else {\n      this._reflexRatio = value;\n      this._calcBars();\n      this._makeGrad();\n    }\n  }\n  get roundBars() {\n    return this._roundBars;\n  }\n  set roundBars(value) {\n    this._roundBars = !!value;\n    this._calcBars();\n  }\n  get smoothing() {\n    return this._analyzer[0].smoothingTimeConstant;\n  }\n  set smoothing(value) {\n    for (const i of [0, 1]) this._analyzer[i].smoothingTimeConstant = value;\n  }\n  get spinSpeed() {\n    return this._spinSpeed;\n  }\n  set spinSpeed(value) {\n    value = +value || 0;\n    if (this._spinSpeed === undefined || value == 0) this._spinAngle = -HALF_PI; // initialize or reset the rotation angle\n    this._spinSpeed = value;\n  }\n  get splitGradient() {\n    return this._splitGradient;\n  }\n  set splitGradient(value) {\n    this._splitGradient = !!value;\n    this._makeGrad();\n  }\n  get stereo() {\n    deprecate('stereo', 'channelLayout');\n    return this._chLayout != CHANNEL_SINGLE;\n  }\n  set stereo(value) {\n    deprecate('stereo', 'channelLayout');\n    this.channelLayout = value ? CHANNEL_VERTICAL : CHANNEL_SINGLE;\n  }\n  get trueLeds() {\n    return this._trueLeds;\n  }\n  set trueLeds(value) {\n    this._trueLeds = !!value;\n  }\n  get volume() {\n    return this._output.gain.value;\n  }\n  set volume(value) {\n    this._output.gain.value = value;\n  }\n  get weightingFilter() {\n    return this._weightingFilter;\n  }\n  set weightingFilter(value) {\n    this._weightingFilter = validateFromList(value, [FILTER_NONE, FILTER_A, FILTER_B, FILTER_C, FILTER_D, FILTER_468], 'toUpperCase');\n  }\n  get width() {\n    return this._width;\n  }\n  set width(w) {\n    this._width = w;\n    this._setCanvas(REASON_USER);\n  }\n\n  // Read only properties\n\n  get audioCtx() {\n    return this._input.context;\n  }\n  get canvas() {\n    return this._ctx.canvas;\n  }\n  get canvasCtx() {\n    return this._ctx;\n  }\n  get connectedSources() {\n    return this._sources;\n  }\n  get connectedTo() {\n    return this._outNodes;\n  }\n  get fps() {\n    return this._fps;\n  }\n  get fsHeight() {\n    return this._fsHeight;\n  }\n  get fsWidth() {\n    return this._fsWidth;\n  }\n  get isAlphaBars() {\n    return this._flg.isAlpha;\n  }\n  get isBandsMode() {\n    return this._flg.isBands;\n  }\n  get isDestroyed() {\n    return this._destroyed;\n  }\n  get isFullscreen() {\n    return this._fsEl && (document.fullscreenElement || document.webkitFullscreenElement) === this._fsEl;\n  }\n  get isLedBars() {\n    return this._flg.isLeds;\n  }\n  get isLumiBars() {\n    return this._flg.isLumi;\n  }\n  get isOctaveBands() {\n    return this._flg.isOctaves;\n  }\n  get isOn() {\n    return !!this._runId;\n  }\n  get isOutlineBars() {\n    return this._flg.isOutline;\n  }\n  get pixelRatio() {\n    return this._pixelRatio;\n  }\n  get isRoundBars() {\n    return this._flg.isRound;\n  }\n  static get version() {\n    return VERSION;\n  }\n\n  /**\r\n   * ==========================================================================\r\n      *\r\n   * PUBLIC METHODS\r\n   *\r\n   * ==========================================================================\r\n   */\n\n  /**\r\n   * Connects an HTML media element or audio node to the analyzer\r\n   *\r\n   * @param {object} an instance of HTMLMediaElement or AudioNode\r\n   * @returns {object} a MediaElementAudioSourceNode object if created from HTML element, or the same input object otherwise\r\n   */\n  connectInput(source) {\n    const isHTML = source instanceof HTMLMediaElement;\n    if (!(isHTML || source.connect)) throw new AudioMotionError(ERR_INVALID_AUDIO_SOURCE);\n\n    // if source is an HTML element, create an audio node for it; otherwise, use the provided audio node\n    const node = isHTML ? this.audioCtx.createMediaElementSource(source) : source;\n    if (!this._sources.includes(node)) {\n      node.connect(this._input);\n      this._sources.push(node);\n    }\n    return node;\n  }\n\n  /**\r\n   * Connects the analyzer output to another audio node\r\n   *\r\n   * @param [{object}] an AudioNode; if undefined, the output is connected to the audio context destination (speakers)\r\n   */\n  connectOutput(node = this.audioCtx.destination) {\n    if (this._outNodes.includes(node)) return;\n    this._output.connect(node);\n    this._outNodes.push(node);\n\n    // when connecting the first node, also connect the analyzer nodes to the merger / output nodes\n    if (this._outNodes.length == 1) {\n      for (const i of [0, 1]) this._analyzer[i].connect(this._chLayout == CHANNEL_SINGLE && !i ? this._output : this._merger, 0, i);\n    }\n  }\n\n  /**\r\n   * Destroys instance\r\n   */\n  destroy() {\n    if (!this._ready) return;\n    const {\n      audioCtx,\n      canvas,\n      _controller,\n      _input,\n      _merger,\n      _observer,\n      _ownCanvas,\n      _ownContext,\n      _splitter\n    } = this;\n    this._destroyed = true;\n    this._ready = false;\n    this.stop();\n\n    // remove event listeners\n    _controller.abort();\n    if (_observer) _observer.disconnect();\n\n    // clear callbacks and fullscreen element\n    this.onCanvasResize = null;\n    this.onCanvasDraw = null;\n    this._fsEl = null;\n\n    // disconnect audio nodes\n    this.disconnectInput();\n    this.disconnectOutput(); // also disconnects analyzer nodes\n    _input.disconnect();\n    _splitter.disconnect();\n    _merger.disconnect();\n\n    // if audio context is our own (not provided by the user), close it\n    if (_ownContext) audioCtx.close();\n\n    // remove canvas from the DOM (if not provided by the user)\n    if (_ownCanvas) canvas.remove();\n\n    // reset flags\n    this._calcBars();\n  }\n\n  /**\r\n   * Disconnects audio sources from the analyzer\r\n   *\r\n   * @param [{object|array}] a connected AudioNode object or an array of such objects; if falsy, all connected nodes are disconnected\r\n   * @param [{boolean}] if true, stops/releases audio tracks from disconnected media streams (e.g. microphone)\r\n   */\n  disconnectInput(sources, stopTracks) {\n    if (!sources) sources = Array.from(this._sources);else if (!Array.isArray(sources)) sources = [sources];\n    for (const node of sources) {\n      const idx = this._sources.indexOf(node);\n      if (stopTracks && node.mediaStream) {\n        for (const track of node.mediaStream.getAudioTracks()) {\n          track.stop();\n        }\n      }\n      if (idx >= 0) {\n        node.disconnect(this._input);\n        this._sources.splice(idx, 1);\n      }\n    }\n  }\n\n  /**\r\n   * Disconnects the analyzer output from other audio nodes\r\n   *\r\n   * @param [{object}] a connected AudioNode object; if undefined, all connected nodes are disconnected\r\n   */\n  disconnectOutput(node) {\n    if (node && !this._outNodes.includes(node)) return;\n    this._output.disconnect(node);\n    this._outNodes = node ? this._outNodes.filter(e => e !== node) : [];\n\n    // if disconnected from all nodes, also disconnect the analyzer nodes so they keep working on Chromium\n    // see https://github.com/hvianna/audioMotion-analyzer/issues/13#issuecomment-808764848\n    if (this._outNodes.length == 0) {\n      for (const i of [0, 1]) this._analyzer[i].disconnect();\n    }\n  }\n\n  /**\r\n   * Returns analyzer bars data\r\n      *\r\n   * @returns {array}\r\n   */\n  getBars() {\n    return Array.from(this._bars, ({\n      posX,\n      freq,\n      freqLo,\n      freqHi,\n      hold,\n      peak,\n      value\n    }) => ({\n      posX,\n      freq,\n      freqLo,\n      freqHi,\n      hold,\n      peak,\n      value\n    }));\n  }\n\n  /**\r\n   * Returns the energy of a frequency, or average energy of a range of frequencies\r\n   *\r\n   * @param [{number|string}] single or initial frequency (Hz), or preset name; if undefined, returns the overall energy\r\n   * @param [{number}] ending frequency (Hz)\r\n   * @returns {number|null} energy value (0 to 1) or null, if the specified preset is unknown\r\n   */\n  getEnergy(startFreq, endFreq) {\n    if (startFreq === undefined) return this._energy.val;\n\n    // if startFreq is a string, check for presets\n    if (startFreq != +startFreq) {\n      if (startFreq == 'peak') return this._energy.peak;\n      const presets = {\n        bass: [20, 250],\n        lowMid: [250, 500],\n        mid: [500, 2e3],\n        highMid: [2e3, 4e3],\n        treble: [4e3, 16e3]\n      };\n      if (!presets[startFreq]) return null;\n      [startFreq, endFreq] = presets[startFreq];\n    }\n    const startBin = this._freqToBin(startFreq),\n      endBin = endFreq ? this._freqToBin(endFreq) : startBin,\n      chnCount = this._chLayout == CHANNEL_SINGLE ? 1 : 2;\n    let energy = 0;\n    for (let channel = 0; channel < chnCount; channel++) {\n      for (let i = startBin; i <= endBin; i++) energy += this._normalizedB(this._fftData[channel][i]);\n    }\n    return energy / (endBin - startBin + 1) / chnCount;\n  }\n\n  /**\r\n   * Returns current analyzer settings in object format\r\n   *\r\n   * @param [{string|array}] a property name or an array of property names to not include in the returned object\r\n   * @returns {object} Options object\r\n   */\n  getOptions(ignore) {\n    if (!Array.isArray(ignore)) ignore = [ignore];\n    let options = {};\n    for (const prop of Object.keys(DEFAULT_SETTINGS)) {\n      if (!ignore.includes(prop)) {\n        if (prop == 'gradient' && this.gradientLeft != this.gradientRight) {\n          options.gradientLeft = this.gradientLeft;\n          options.gradientRight = this.gradientRight;\n        } else if (prop != 'start') options[prop] = this[prop];\n      }\n    }\n    return options;\n  }\n\n  /**\r\n   * Registers a custom gradient\r\n   *\r\n   * @param {string} name\r\n   * @param {object} options\r\n   */\n  registerGradient(name, options) {\n    if (typeof name != 'string' || name.trim().length == 0) throw new AudioMotionError(ERR_GRADIENT_INVALID_NAME);\n    if (typeof options != 'object') throw new AudioMotionError(ERR_GRADIENT_NOT_AN_OBJECT);\n    const {\n      colorStops\n    } = options;\n    if (!Array.isArray(colorStops) || !colorStops.length) throw new AudioMotionError(ERR_GRADIENT_MISSING_COLOR);\n    const count = colorStops.length,\n      isInvalid = val => +val != val || val < 0 || val > 1;\n\n    // normalize all colorStops as objects with `pos`, `color` and `level` properties\n    colorStops.forEach((colorStop, index) => {\n      const pos = index / Math.max(1, count - 1);\n      if (typeof colorStop != 'object')\n        // only color string was defined\n        colorStops[index] = {\n          pos,\n          color: colorStop\n        };else if (isInvalid(colorStop.pos)) colorStop.pos = pos;\n      if (isInvalid(colorStop.level)) colorStops[index].level = 1 - index / count;\n    });\n\n    // make sure colorStops is in descending `level` order and that the first one has `level == 1`\n    // this is crucial for proper operation of 'bar-level' colorMode!\n    colorStops.sort((a, b) => a.level < b.level ? 1 : a.level > b.level ? -1 : 0);\n    colorStops[0].level = 1;\n    this._gradients[name] = {\n      bgColor: options.bgColor || GRADIENT_DEFAULT_BGCOLOR,\n      dir: options.dir,\n      colorStops: colorStops\n    };\n\n    // if the registered gradient is one of the currently selected gradients, regenerate them\n    if (this._selectedGrads.includes(name)) this._makeGrad();\n  }\n\n  /**\r\n   * Set dimensions of analyzer's canvas\r\n   *\r\n   * @param {number} w width in pixels\r\n   * @param {number} h height in pixels\r\n   */\n  setCanvasSize(w, h) {\n    this._width = w;\n    this._height = h;\n    this._setCanvas(REASON_USER);\n  }\n\n  /**\r\n   * Set desired frequency range\r\n   *\r\n   * @param {number} min lowest frequency represented in the x-axis\r\n   * @param {number} max highest frequency represented in the x-axis\r\n   */\n  setFreqRange(min, max) {\n    if (min < 1 || max < 1) throw new AudioMotionError(ERR_FREQUENCY_TOO_LOW);else {\n      this._minFreq = Math.min(min, max);\n      this.maxFreq = Math.max(min, max); // use the setter for maxFreq\n    }\n  }\n\n  /**\r\n   * Set custom parameters for LED effect\r\n   * If called with no arguments or if any property is invalid, clears any previous custom parameters\r\n   *\r\n   * @param {object} [params]\r\n   */\n  setLedParams(params) {\n    let maxLeds, spaceV, spaceH;\n\n    // coerce parameters to Number; `NaN` results are rejected in the condition below\n    if (params) {\n      maxLeds = params.maxLeds | 0,\n      // ensure integer\n      spaceV = +params.spaceV, spaceH = +params.spaceH;\n    }\n    this._ledParams = maxLeds > 0 && spaceV > 0 && spaceH >= 0 ? [maxLeds, spaceV, spaceH] : undefined;\n    this._calcBars();\n  }\n\n  /**\r\n   * Shorthand function for setting several options at once\r\n   *\r\n   * @param {object} options\r\n   */\n  setOptions(options) {\n    this._setProps(options);\n  }\n\n  /**\r\n   * Adjust the analyzer's sensitivity\r\n   *\r\n   * @param {number} min minimum decibels value\r\n   * @param {number} max maximum decibels value\r\n   */\n  setSensitivity(min, max) {\n    for (const i of [0, 1]) {\n      this._analyzer[i].minDecibels = Math.min(min, max);\n      this._analyzer[i].maxDecibels = Math.max(min, max);\n    }\n  }\n\n  /**\r\n   * Start the analyzer\r\n   */\n  start() {\n    this.toggleAnalyzer(true);\n  }\n\n  /**\r\n   * Stop the analyzer\r\n   */\n  stop() {\n    this.toggleAnalyzer(false);\n  }\n\n  /**\r\n   * Start / stop canvas animation\r\n   *\r\n   * @param {boolean} [force] if undefined, inverts the current state\r\n   * @returns {boolean} resulting state after the change\r\n   */\n  toggleAnalyzer(force) {\n    const hasStarted = this.isOn;\n    if (force === undefined) force = !hasStarted;\n\n    // Stop the analyzer if it was already running and must be disabled\n    if (hasStarted && !force) {\n      cancelAnimationFrame(this._runId);\n      this._runId = 0;\n    }\n    // Start the analyzer if it was stopped and must be enabled\n    else if (!hasStarted && force && !this._destroyed) {\n      this._frames = 0;\n      this._time = performance.now();\n      this._runId = requestAnimationFrame(timestamp => this._draw(timestamp)); // arrow function preserves the scope of *this*\n    }\n    return this.isOn;\n  }\n\n  /**\r\n   * Toggles canvas full-screen mode\r\n   */\n  toggleFullscreen() {\n    if (this.isFullscreen) {\n      if (document.exitFullscreen) document.exitFullscreen();else if (document.webkitExitFullscreen) document.webkitExitFullscreen();\n    } else {\n      const fsEl = this._fsEl;\n      if (!fsEl) return;\n      if (fsEl.requestFullscreen) fsEl.requestFullscreen();else if (fsEl.webkitRequestFullscreen) fsEl.webkitRequestFullscreen();\n    }\n  }\n\n  /**\r\n   * ==========================================================================\r\n   *\r\n   * PRIVATE METHODS\r\n   *\r\n   * ==========================================================================\r\n   */\n\n  /**\r\n   * Return the frequency (in Hz) for a given FFT bin\r\n   */\n  _binToFreq(bin) {\n    return bin * this.audioCtx.sampleRate / this.fftSize || 1; // returns 1 for bin 0\n  }\n\n  /**\r\n   * Compute all internal data required for the analyzer, based on its current settings\r\n   */\n  _calcBars() {\n    const bars = this._bars = []; // initialize object property\n\n    if (!this._ready) {\n      this._flg = {\n        isAlpha: false,\n        isBands: false,\n        isLeds: false,\n        isLumi: false,\n        isOctaves: false,\n        isOutline: false,\n        isRound: false,\n        noLedGap: false\n      };\n      return;\n    }\n    const {\n        _ansiBands,\n        _barSpace,\n        canvas,\n        _chLayout,\n        _maxFreq,\n        _minFreq,\n        _mirror,\n        _mode,\n        _radial,\n        _radialInvert,\n        _reflexRatio\n      } = this,\n      centerX = canvas.width >> 1,\n      centerY = canvas.height >> 1,\n      isDualVertical = _chLayout == CHANNEL_VERTICAL && !_radial,\n      isDualHorizontal = _chLayout == CHANNEL_HORIZONTAL,\n      // COMPUTE FLAGS\n\n      isBands = _mode % 10 != 0,\n      // true for modes 1 to 9\n      isOctaves = isBands && this._frequencyScale == SCALE_LOG,\n      isLeds = this._showLeds && isBands && !_radial,\n      isLumi = this._lumiBars && isBands && !_radial,\n      isAlpha = this._alphaBars && !isLumi && _mode != MODE_GRAPH,\n      isOutline = this._outlineBars && isBands && !isLumi && !isLeds,\n      isRound = this._roundBars && isBands && !isLumi && !isLeds,\n      noLedGap = _chLayout != CHANNEL_VERTICAL || _reflexRatio > 0 && !isLumi,\n      // COMPUTE AUXILIARY VALUES\n\n      // channelHeight is the total canvas height dedicated to each channel, including the reflex area, if any)\n      channelHeight = canvas.height - (isDualVertical && !isLeds ? .5 : 0) >> isDualVertical,\n      // analyzerHeight is the effective height used to render the analyzer, excluding the reflex area\n      analyzerHeight = channelHeight * (isLumi || _radial ? 1 : 1 - _reflexRatio) | 0,\n      analyzerWidth = canvas.width - centerX * (isDualHorizontal || _mirror != 0),\n      // channelGap is **0** if isLedDisplay == true (LEDs already have spacing); **1** if canvas height is odd (windowed); **2** if it's even\n      // TODO: improve this, make it configurable?\n      channelGap = isDualVertical ? canvas.height - channelHeight * 2 : 0,\n      initialX = centerX * (_mirror == -1 && !isDualHorizontal && !_radial);\n    let innerRadius = Math.min(canvas.width, canvas.height) * .375 * (_chLayout == CHANNEL_VERTICAL ? 1 : this._radius) | 0,\n      outerRadius = Math.min(centerX, centerY);\n    if (_radialInvert && _chLayout != CHANNEL_VERTICAL) [innerRadius, outerRadius] = [outerRadius, innerRadius];\n\n    /**\r\n     *\tCREATE ANALYZER BANDS\r\n     *\r\n     *\tUSES:\r\n     *\t\tanalyzerWidth\r\n     *\t\tinitialX\r\n     *\t\tisBands\r\n     *\t\tisOctaves\r\n     *\r\n     *\tGENERATES:\r\n     *\t\tbars (populates this._bars)\r\n     *\t\tbardWidth\r\n     *\t\tscaleMin\r\n     *\t\tunitWidth\r\n     */\n\n    // helper function to add a bar to the bars array\n    // bar object format:\n    // {\n    //\t posX,\n    //   freq,\n    //   freqLo,\n    //   freqHi,\n    //   binLo,\n    //   binHi,\n    //   ratioLo,\n    //   ratioHi,\n    //   peak,    // peak value\n    //   hold,    // peak hold frames (negative value indicates peak falling / fading)\n    //   alpha,   // peak alpha (used by fadePeaks)\n    //   value    // current bar value\n    // }\n    const barsPush = args => bars.push({\n      ...args,\n      peak: [0, 0],\n      hold: [0],\n      alpha: [0],\n      value: [0]\n    });\n\n    /*\r\n    \tA simple interpolation is used to obtain an approximate amplitude value for any given frequency,\r\n    \tfrom the available FFT data. We find the FFT bin which closer matches the desired frequency\tand\r\n    \tinterpolate its value with that of the next adjacent bin, like so:\r\n    \t\t\t\tv = v0 + ( v1 - v0 ) * ( log2( f / f0 ) / log2( f1 / f0 ) )\r\n    \t\t                       \\__________________________________/\r\n    \t\t                                        |\r\n    \t\t                                      ratio\r\n    \t\twhere:\r\n    \t\t\t\tf  - desired frequency\r\n    \t\tv  - amplitude (volume) of desired frequency\r\n    \t\tf0 - frequency represented by the lower FFT bin\r\n    \t\tf1 - frequency represented by the upper FFT bin\r\n    \t\tv0 - amplitude of f0\r\n    \t\tv1 - amplitude of f1\r\n    \t\t\tratio is calculated in advance here, to reduce computational complexity during real-time rendering.\r\n    */\n\n    // helper function to calculate FFT bin and interpolation ratio for a given frequency\n    const calcRatio = freq => {\n      const bin = this._freqToBin(freq, 'floor'),\n        // find closest FFT bin\n        lower = this._binToFreq(bin),\n        upper = this._binToFreq(bin + 1),\n        ratio = Math.log2(freq / lower) / Math.log2(upper / lower);\n      return [bin, ratio];\n    };\n    let barWidth, scaleMin, unitWidth;\n    if (isOctaves) {\n      // helper function to round a value to a given number of significant digits\n      // `atLeast` set to true prevents reducing the number of integer significant digits\n      const roundSD = (value, digits, atLeast) => +value.toPrecision(atLeast ? Math.max(digits, 1 + Math.log10(value) | 0) : digits);\n\n      // helper function to find the nearest preferred number (Renard series) for a given value\n      const nearestPreferred = value => {\n        // R20 series is used here, as it provides closer approximations for 1/2 octave bands (non-standard)\n        const preferred = [1, 1.12, 1.25, 1.4, 1.6, 1.8, 2, 2.24, 2.5, 2.8, 3.15, 3.55, 4, 4.5, 5, 5.6, 6.3, 7.1, 8, 9, 10],\n          power = Math.log10(value) | 0,\n          normalized = value / 10 ** power;\n        let i = 1;\n        while (i < preferred.length && normalized > preferred[i]) i++;\n        if (normalized - preferred[i - 1] < preferred[i] - normalized) i--;\n        return (preferred[i] * 10 ** (power + 5) | 0) / 1e5; // keep 5 significant digits\n      };\n\n      // ANSI standard octave bands use the base-10 frequency ratio, as preferred by [ANSI S1.11-2004, p.2]\n      // The equal-tempered scale uses the base-2 ratio\n      const bands = [0, 24, 12, 8, 6, 4, 3, 2, 1][_mode],\n        bandWidth = _ansiBands ? 10 ** (3 / (bands * 10)) : 2 ** (1 / bands),\n        // 10^(3/10N) or 2^(1/N)\n        halfBand = bandWidth ** .5;\n      let analyzerBars = [],\n        currFreq = _ansiBands ? 7.94328235 / (bands % 2 ? 1 : halfBand) : C_1;\n      // For ANSI bands with even denominators (all except 1/1 and 1/3), the reference frequency (1 kHz)\n      // must fall on the edges of a pair of adjacent bands, instead of midband [ANSI S1.11-2004, p.2]\n      // In the equal-tempered scale, all midband frequencies represent a musical note or quarter-tone.\n\n      do {\n        let freq = currFreq; // midband frequency\n\n        const freqLo = roundSD(freq / halfBand, 4, true),\n          // lower edge frequency\n          freqHi = roundSD(freq * halfBand, 4, true),\n          // upper edge frequency\n          [binLo, ratioLo] = calcRatio(freqLo),\n          [binHi, ratioHi] = calcRatio(freqHi);\n\n        // for 1/1, 1/2 and 1/3 ANSI bands, use the preferred numbers to find the nominal midband frequency\n        // for 1/4 to 1/24, round to 2 or 3 significant digits, according to the MSD [ANSI S1.11-2004, p.12]\n        if (_ansiBands) freq = bands < 4 ? nearestPreferred(freq) : roundSD(freq, freq.toString()[0] < 5 ? 3 : 2);else freq = roundSD(freq, 4, true);\n        if (freq >= _minFreq) barsPush({\n          posX: 0,\n          freq,\n          freqLo,\n          freqHi,\n          binLo,\n          binHi,\n          ratioLo,\n          ratioHi\n        });\n        currFreq *= bandWidth;\n      } while (currFreq <= _maxFreq);\n      barWidth = analyzerWidth / bars.length;\n      bars.forEach((bar, index) => bar.posX = initialX + index * barWidth);\n      const firstBar = bars[0],\n        lastBar = bars[bars.length - 1];\n      scaleMin = this._freqScaling(firstBar.freqLo);\n      unitWidth = analyzerWidth / (this._freqScaling(lastBar.freqHi) - scaleMin);\n\n      // clamp edge frequencies to minFreq / maxFreq, if necessary\n      // this is done after computing scaleMin and unitWidth, for the proper positioning of labels on the X-axis\n      if (firstBar.freqLo < _minFreq) {\n        firstBar.freqLo = _minFreq;\n        [firstBar.binLo, firstBar.ratioLo] = calcRatio(_minFreq);\n      }\n      if (lastBar.freqHi > _maxFreq) {\n        lastBar.freqHi = _maxFreq;\n        [lastBar.binHi, lastBar.ratioHi] = calcRatio(_maxFreq);\n      }\n    } else if (isBands) {\n      // a bands mode is selected, but frequency scale is not logarithmic\n\n      const bands = [0, 24, 12, 8, 6, 4, 3, 2, 1][_mode] * 10;\n      const invFreqScaling = x => {\n        switch (this._frequencyScale) {\n          case SCALE_BARK:\n            return 1960 / (26.81 / (x + .53) - 1);\n          case SCALE_MEL:\n            return 700 * (2 ** x - 1);\n          case SCALE_LINEAR:\n            return x;\n        }\n      };\n      barWidth = analyzerWidth / bands;\n      scaleMin = this._freqScaling(_minFreq);\n      unitWidth = analyzerWidth / (this._freqScaling(_maxFreq) - scaleMin);\n      for (let i = 0, posX = 0; i < bands; i++, posX += barWidth) {\n        const freqLo = invFreqScaling(scaleMin + posX / unitWidth),\n          freq = invFreqScaling(scaleMin + (posX + barWidth / 2) / unitWidth),\n          freqHi = invFreqScaling(scaleMin + (posX + barWidth) / unitWidth),\n          [binLo, ratioLo] = calcRatio(freqLo),\n          [binHi, ratioHi] = calcRatio(freqHi);\n        barsPush({\n          posX: initialX + posX,\n          freq,\n          freqLo,\n          freqHi,\n          binLo,\n          binHi,\n          ratioLo,\n          ratioHi\n        });\n      }\n    } else {\n      // Discrete frequencies modes\n      barWidth = 1;\n      scaleMin = this._freqScaling(_minFreq);\n      unitWidth = analyzerWidth / (this._freqScaling(_maxFreq) - scaleMin);\n      const minIndex = this._freqToBin(_minFreq, 'floor'),\n        maxIndex = this._freqToBin(_maxFreq);\n      let lastPos = -999;\n      for (let i = minIndex; i <= maxIndex; i++) {\n        const freq = this._binToFreq(i),\n          // frequency represented by this index\n          posX = initialX + Math.round(unitWidth * (this._freqScaling(freq) - scaleMin)); // avoid fractionary pixel values\n\n        // if it's on a different X-coordinate, create a new bar for this frequency\n        if (posX > lastPos) {\n          barsPush({\n            posX,\n            freq,\n            freqLo: freq,\n            freqHi: freq,\n            binLo: i,\n            binHi: i,\n            ratioLo: 0,\n            ratioHi: 0\n          });\n          lastPos = posX;\n        } // otherwise, add this frequency to the last bar's range\n        else if (bars.length) {\n          const lastBar = bars[bars.length - 1];\n          lastBar.binHi = i;\n          lastBar.freqHi = freq;\n          lastBar.freq = (lastBar.freqLo * freq) ** .5; // compute center frequency (geometric mean)\n        }\n      }\n    }\n\n    /**\r\n     *  COMPUTE ATTRIBUTES FOR THE LED BARS\r\n     *\r\n     *\tUSES:\r\n     *\t\tanalyzerHeight\r\n     *\t\tbarWidth\r\n     *\t\tnoLedGap\r\n     *\r\n     *\tGENERATES:\r\n     * \t\tspaceH\r\n     * \t\tspaceV\r\n     *\t\tthis._leds\r\n     */\n\n    let spaceH = 0,\n      spaceV = 0;\n    if (isLeds) {\n      // adjustment for high pixel-ratio values on low-resolution screens (Android TV)\n      const dPR = this._pixelRatio / (window.devicePixelRatio > 1 && window.screen.height <= 540 ? 2 : 1);\n      const params = [[], [128, 3, .45],\n      // mode 1\n      [128, 4, .225],\n      // mode 2\n      [96, 6, .225],\n      // mode 3\n      [80, 6, .225],\n      // mode 4\n      [80, 6, .125],\n      // mode 5\n      [64, 6, .125],\n      // mode 6\n      [48, 8, .125],\n      // mode 7\n      [24, 16, .125] // mode 8\n      ];\n\n      // use custom LED parameters if set, or the default parameters for the current mode\n      const customParams = this._ledParams,\n        [maxLeds, spaceVRatio, spaceHRatio] = customParams || params[_mode];\n      let ledCount,\n        maxHeight = analyzerHeight;\n      if (customParams) {\n        const minHeight = 2 * dPR;\n        let blockHeight;\n        ledCount = maxLeds + 1;\n        do {\n          ledCount--;\n          blockHeight = maxHeight / ledCount / (1 + spaceVRatio);\n          spaceV = blockHeight * spaceVRatio;\n        } while ((blockHeight < minHeight || spaceV < minHeight) && ledCount > 1);\n      } else {\n        // calculate vertical spacing - aim for the reference ratio, but make sure it's at least 2px\n        const refRatio = 540 / spaceVRatio;\n        spaceV = Math.min(spaceVRatio * dPR, Math.max(2, maxHeight / refRatio + .1 | 0));\n      }\n\n      // remove the extra spacing below the last line of LEDs\n      if (noLedGap) maxHeight += spaceV;\n\n      // recalculate the number of leds, considering the effective spaceV\n      if (!customParams) ledCount = Math.min(maxLeds, maxHeight / (spaceV * 2) | 0);\n      spaceH = spaceHRatio >= 1 ? spaceHRatio : barWidth * spaceHRatio;\n      this._leds = [ledCount, spaceH, spaceV, maxHeight / ledCount - spaceV // ledHeight\n      ];\n    }\n\n    // COMPUTE ADDITIONAL BAR POSITIONING, ACCORDING TO THE CURRENT SETTINGS\n    // uses: _barSpace, barWidth, spaceH\n\n    const barSpacePx = Math.min(barWidth - 1, _barSpace * (_barSpace > 0 && _barSpace < 1 ? barWidth : 1));\n    if (isBands) barWidth -= Math.max(isLeds ? spaceH : 0, barSpacePx);\n    bars.forEach((bar, index) => {\n      let posX = bar.posX,\n        width = barWidth;\n\n      // in bands modes we need to update bar.posX to account for bar/led spacing\n\n      if (isBands) {\n        if (_barSpace == 0 && !isLeds) {\n          // when barSpace == 0 use integer values for perfect gapless positioning\n          posX |= 0;\n          width |= 0;\n          if (index > 0 && posX > bars[index - 1].posX + bars[index - 1].width) {\n            posX--;\n            width++;\n          }\n        } else posX += Math.max(isLeds ? spaceH : 0, barSpacePx) / 2;\n        bar.posX = posX; // update\n      }\n      bar.barCenter = posX + (barWidth == 1 ? 0 : width / 2);\n      bar.width = width;\n    });\n\n    // COMPUTE CHANNEL COORDINATES (uses spaceV)\n\n    const channelCoords = [];\n    for (const channel of [0, 1]) {\n      const channelTop = _chLayout == CHANNEL_VERTICAL ? (channelHeight + channelGap) * channel : 0,\n        channelBottom = channelTop + channelHeight,\n        analyzerBottom = channelTop + analyzerHeight - (!isLeds || noLedGap ? 0 : spaceV);\n      channelCoords.push({\n        channelTop,\n        channelBottom,\n        analyzerBottom\n      });\n    }\n\n    // SAVE INTERNAL PROPERTIES\n\n    this._aux = {\n      analyzerHeight,\n      analyzerWidth,\n      centerX,\n      centerY,\n      channelCoords,\n      channelHeight,\n      channelGap,\n      initialX,\n      innerRadius,\n      outerRadius,\n      scaleMin,\n      unitWidth\n    };\n    this._flg = {\n      isAlpha,\n      isBands,\n      isLeds,\n      isLumi,\n      isOctaves,\n      isOutline,\n      isRound,\n      noLedGap\n    };\n\n    // generate the X-axis and radial scales\n    this._createScales();\n  }\n\n  /**\r\n   * Generate the X-axis and radial scales in auxiliary canvases\r\n   */\n  _createScales() {\n    if (!this._ready) return;\n    const {\n        analyzerWidth,\n        initialX,\n        innerRadius,\n        scaleMin,\n        unitWidth\n      } = this._aux,\n      {\n        canvas,\n        _frequencyScale,\n        _mirror,\n        _noteLabels,\n        _radial,\n        _scaleX,\n        _scaleR\n      } = this,\n      canvasX = _scaleX.canvas,\n      canvasR = _scaleR.canvas,\n      freqLabels = [],\n      isDualHorizontal = this._chLayout == CHANNEL_HORIZONTAL,\n      isDualVertical = this._chLayout == CHANNEL_VERTICAL,\n      minDimension = Math.min(canvas.width, canvas.height),\n      scale = ['C',, 'D',, 'E', 'F',, 'G',, 'A',, 'B'],\n      // for note labels (no sharp notes)\n      scaleHeight = minDimension / 34 | 0,\n      // circular scale height (radial mode)\n      fontSizeX = canvasX.height >> 1,\n      fontSizeR = scaleHeight >> 1,\n      labelWidthX = fontSizeX * (_noteLabels ? .7 : 1.5),\n      labelWidthR = fontSizeR * (_noteLabels ? 1 : 2),\n      root12 = 2 ** (1 / 12);\n    if (!_noteLabels && (this._ansiBands || _frequencyScale != SCALE_LOG)) {\n      freqLabels.push(16, 31.5, 63, 125, 250, 500, 1e3, 2e3, 4e3);\n      if (_frequencyScale == SCALE_LINEAR) freqLabels.push(6e3, 8e3, 10e3, 12e3, 14e3, 16e3, 18e3, 20e3, 22e3);else freqLabels.push(8e3, 16e3);\n    } else {\n      let freq = C_1;\n      for (let octave = -1; octave < 11; octave++) {\n        for (let note = 0; note < 12; note++) {\n          if (freq >= this._minFreq && freq <= this._maxFreq) {\n            const pitch = scale[note],\n              isC = pitch == 'C';\n            if (pitch && _noteLabels && !_mirror && !isDualHorizontal || isC) freqLabels.push(_noteLabels ? [freq, pitch + (isC ? octave : '')] : freq);\n          }\n          freq *= root12;\n        }\n      }\n    }\n\n    // in radial dual-vertical layout, the scale is positioned exactly between both channels, by making the canvas a bit larger than the inner diameter\n    canvasR.width = canvasR.height = Math.max(minDimension * .15, (innerRadius << 1) + isDualVertical * scaleHeight);\n    const centerR = canvasR.width >> 1,\n      radialY = centerR - scaleHeight * .7; // vertical position of text labels in the circular scale\n\n    // helper function\n    const radialLabel = (x, label) => {\n      const angle = TAU * (x / canvas.width),\n        adjAng = angle - HALF_PI,\n        // rotate angles so 0 is at the top\n        posX = radialY * Math.cos(adjAng),\n        posY = radialY * Math.sin(adjAng);\n      _scaleR.save();\n      _scaleR.translate(centerR + posX, centerR + posY);\n      _scaleR.rotate(angle);\n      _scaleR.fillText(label, 0, 0);\n      _scaleR.restore();\n    };\n\n    // clear scale canvas\n    canvasX.width |= 0;\n    _scaleX.fillStyle = _scaleR.strokeStyle = SCALEX_BACKGROUND_COLOR;\n    _scaleX.fillRect(0, 0, canvasX.width, canvasX.height);\n    _scaleR.arc(centerR, centerR, centerR - scaleHeight / 2, 0, TAU);\n    _scaleR.lineWidth = scaleHeight;\n    _scaleR.stroke();\n    _scaleX.fillStyle = _scaleR.fillStyle = SCALEX_LABEL_COLOR;\n    _scaleX.font = `${fontSizeX}px ${FONT_FAMILY}`;\n    _scaleR.font = `${fontSizeR}px ${FONT_FAMILY}`;\n    _scaleX.textAlign = _scaleR.textAlign = 'center';\n    let prevX = -labelWidthX / 4,\n      prevR = -labelWidthR;\n    for (const item of freqLabels) {\n      const [freq, label] = Array.isArray(item) ? item : [item, item < 1e3 ? item | 0 : `${(item / 100 | 0) / 10}k`],\n        x = unitWidth * (this._freqScaling(freq) - scaleMin),\n        y = canvasX.height * .75,\n        isC = label[0] == 'C',\n        maxW = fontSizeX * (_noteLabels && !_mirror && !isDualHorizontal ? isC ? 1.2 : .6 : 3);\n\n      // set label color - no highlight when mirror effect is active (only Cs displayed)\n      _scaleX.fillStyle = _scaleR.fillStyle = isC && !_mirror && !isDualHorizontal ? SCALEX_HIGHLIGHT_COLOR : SCALEX_LABEL_COLOR;\n\n      // prioritizes which note labels are displayed, due to the restricted space on some ranges/scales\n      if (_noteLabels) {\n        const isLog = _frequencyScale == SCALE_LOG,\n          isLinear = _frequencyScale == SCALE_LINEAR;\n        let allowedLabels = ['C'];\n        if (isLog || freq > 2e3 || !isLinear && freq > 250 || (!_radial || isDualVertical) && (!isLinear && freq > 125 || freq > 1e3)) allowedLabels.push('G');\n        if (isLog || freq > 4e3 || !isLinear && freq > 500 || (!_radial || isDualVertical) && (!isLinear && freq > 250 || freq > 2e3)) allowedLabels.push('E');\n        if (isLinear && freq > 4e3 || (!_radial || isDualVertical) && (isLog || freq > 2e3 || !isLinear && freq > 500)) allowedLabels.push('D', 'F', 'A', 'B');\n        if (!allowedLabels.includes(label[0])) continue; // skip this label\n      }\n\n      // linear scale\n      if (x >= prevX + labelWidthX / 2 && x <= analyzerWidth) {\n        _scaleX.fillText(label, isDualHorizontal && _mirror == -1 ? analyzerWidth - x : initialX + x, y, maxW);\n        if (isDualHorizontal || _mirror && (x > labelWidthX || _mirror == 1)) _scaleX.fillText(label, isDualHorizontal && _mirror != 1 ? analyzerWidth + x : (initialX || canvas.width) - x, y, maxW);\n        prevX = x + Math.min(maxW, _scaleX.measureText(label).width) / 2;\n      }\n\n      // radial scale\n      if (x >= prevR + labelWidthR && x < analyzerWidth - labelWidthR) {\n        // avoid overlapping the last label over the first one\n        radialLabel(isDualHorizontal && _mirror == 1 ? analyzerWidth - x : x, label);\n        if (isDualHorizontal || _mirror && (x > labelWidthR || _mirror == 1))\n          // avoid overlapping of first labels on mirror mode\n          radialLabel(isDualHorizontal && _mirror != -1 ? analyzerWidth + x : -x, label);\n        prevR = x;\n      }\n    }\n  }\n\n  /**\r\n   * Redraw the canvas\r\n   * this is called 60 times per second by requestAnimationFrame()\r\n   */\n  _draw(timestamp) {\n    // schedule next canvas update\n    this._runId = requestAnimationFrame(timestamp => this._draw(timestamp));\n\n    // frame rate control\n    const elapsed = timestamp - this._time,\n      // time since last FPS computation\n      frameTime = timestamp - this._last,\n      // time since last rendered frame\n      targetInterval = this._maxFPS ? 975 / this._maxFPS : 0; // small tolerance for best results\n\n    if (frameTime < targetInterval) return;\n    this._last = timestamp - (targetInterval ? frameTime % targetInterval : 0); // thanks https://stackoverflow.com/a/19772220/2370385\n    this._frames++;\n    if (elapsed >= 1000) {\n      // update FPS every second\n      this._fps = this._frames / elapsed * 1000;\n      this._frames = 0;\n      this._time = timestamp;\n    }\n\n    // initialize local constants\n\n    const {\n        isAlpha,\n        isBands,\n        isLeds,\n        isLumi,\n        isOctaves,\n        isOutline,\n        isRound,\n        noLedGap\n      } = this._flg,\n      {\n        analyzerHeight,\n        centerX,\n        centerY,\n        channelCoords,\n        channelHeight,\n        channelGap,\n        initialX,\n        innerRadius,\n        outerRadius\n      } = this._aux,\n      {\n        _bars,\n        canvas,\n        _canvasGradients,\n        _chLayout,\n        _colorMode,\n        _ctx,\n        _energy,\n        _fadePeaks,\n        fillAlpha,\n        _fps,\n        _linearAmplitude,\n        _lineWidth,\n        maxDecibels,\n        minDecibels,\n        _mirror,\n        _mode,\n        overlay,\n        _radial,\n        showBgColor,\n        showPeaks,\n        useCanvas,\n        _weightingFilter\n      } = this,\n      canvasX = this._scaleX.canvas,\n      canvasR = this._scaleR.canvas,\n      fadeFrames = _fps * this._peakFadeTime / 1e3,\n      fpsSquared = _fps ** 2,\n      gravity = this._gravity * 1e3,\n      holdFrames = _fps * this._peakHoldTime / 1e3,\n      isDualCombined = _chLayout == CHANNEL_COMBINED,\n      isDualHorizontal = _chLayout == CHANNEL_HORIZONTAL,\n      isDualVertical = _chLayout == CHANNEL_VERTICAL,\n      isSingle = _chLayout == CHANNEL_SINGLE,\n      isTrueLeds = isLeds && this._trueLeds && _colorMode == COLOR_GRADIENT,\n      analyzerWidth = _radial ? canvas.width : this._aux.analyzerWidth,\n      finalX = initialX + analyzerWidth,\n      showPeakLine = showPeaks && this._peakLine && _mode == MODE_GRAPH,\n      maxBarHeight = _radial ? outerRadius - innerRadius : analyzerHeight,\n      nominalMaxHeight = maxBarHeight / this._pixelRatio,\n      // for consistent gravity on lo-res or hi-dpi\n      dbRange = maxDecibels - minDecibels,\n      [ledCount, ledSpaceH, ledSpaceV, ledHeight] = this._leds || [];\n    if (_energy.val > 0 && _fps > 0) this._spinAngle += this._spinSpeed * TAU / 60 / _fps; // spinSpeed * angle increment per frame for 1 RPM\n\n    /* HELPER FUNCTIONS */\n\n    // create Reflex effect\n    const doReflex = channel => {\n      if (this._reflexRatio > 0 && !isLumi && !_radial) {\n        let posY, height;\n        if (this.reflexFit || isDualVertical) {\n          // always fit reflex in vertical stereo mode\n          posY = isDualVertical && channel == 0 ? channelHeight + channelGap : 0;\n          height = channelHeight - analyzerHeight;\n        } else {\n          posY = canvas.height - analyzerHeight * 2;\n          height = analyzerHeight;\n        }\n        _ctx.save();\n\n        // set alpha and brightness for the reflection\n        _ctx.globalAlpha = this.reflexAlpha;\n        if (this.reflexBright != 1) _ctx.filter = `brightness(${this.reflexBright})`;\n\n        // create the reflection\n        _ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\n        _ctx.drawImage(canvas, 0, channelCoords[channel].channelTop, canvas.width, analyzerHeight, 0, posY, canvas.width, height);\n        _ctx.restore();\n      }\n    };\n\n    // draw scale on X-axis\n    const drawScaleX = () => {\n      if (this.showScaleX) {\n        if (_radial) {\n          _ctx.save();\n          _ctx.translate(centerX, centerY);\n          if (this._spinSpeed) _ctx.rotate(this._spinAngle + HALF_PI);\n          _ctx.drawImage(canvasR, -canvasR.width >> 1, -canvasR.width >> 1);\n          _ctx.restore();\n        } else _ctx.drawImage(canvasX, 0, canvas.height - canvasX.height);\n      }\n    };\n\n    // returns the gain (in dB) for a given frequency, considering the currently selected weighting filter\n    const weightingdB = freq => {\n      const f2 = freq ** 2,\n        SQ20_6 = 424.36,\n        SQ107_7 = 11599.29,\n        SQ158_5 = 25122.25,\n        SQ737_9 = 544496.41,\n        SQ12194 = 148693636,\n        linearTodB = value => 20 * Math.log10(value);\n      switch (_weightingFilter) {\n        case FILTER_A:\n          // A-weighting https://en.wikipedia.org/wiki/A-weighting\n          const rA = SQ12194 * f2 ** 2 / ((f2 + SQ20_6) * Math.sqrt((f2 + SQ107_7) * (f2 + SQ737_9)) * (f2 + SQ12194));\n          return 2 + linearTodB(rA);\n        case FILTER_B:\n          const rB = SQ12194 * f2 * freq / ((f2 + SQ20_6) * Math.sqrt(f2 + SQ158_5) * (f2 + SQ12194));\n          return .17 + linearTodB(rB);\n        case FILTER_C:\n          const rC = SQ12194 * f2 / ((f2 + SQ20_6) * (f2 + SQ12194));\n          return .06 + linearTodB(rC);\n        case FILTER_D:\n          const h = ((1037918.48 - f2) ** 2 + 1080768.16 * f2) / ((9837328 - f2) ** 2 + 11723776 * f2),\n            rD = freq / 6.8966888496476e-5 * Math.sqrt(h / ((f2 + 79919.29) * (f2 + 1345600)));\n          return linearTodB(rD);\n        case FILTER_468:\n          // ITU-R 468 https://en.wikipedia.org/wiki/ITU-R_468_noise_weighting\n          const h1 = -4.737338981378384e-24 * freq ** 6 + 2.043828333606125e-15 * freq ** 4 - 1.363894795463638e-7 * f2 + 1,\n            h2 = 1.306612257412824e-19 * freq ** 5 - 2.118150887518656e-11 * freq ** 3 + 5.559488023498642e-4 * freq,\n            rI = 1.246332637532143e-4 * freq / Math.hypot(h1, h2);\n          return 18.2 + linearTodB(rI);\n      }\n      return 0; // unknown filter\n    };\n\n    // draws (stroke) a bar from x,y1 to x,y2\n    const strokeBar = (x, y1, y2) => {\n      _ctx.beginPath();\n      _ctx.moveTo(x, y1);\n      _ctx.lineTo(x, y2);\n      _ctx.stroke();\n    };\n\n    // conditionally strokes current path on canvas\n    const strokeIf = flag => {\n      if (flag && _lineWidth) {\n        const alpha = _ctx.globalAlpha;\n        _ctx.globalAlpha = 1;\n        _ctx.stroke();\n        _ctx.globalAlpha = alpha;\n      }\n    };\n\n    // converts a value in [0;1] range to a height in pixels that fits into the current LED elements\n    const ledPosY = value => Math.max(0, (value * ledCount | 0) * (ledHeight + ledSpaceV) - ledSpaceV);\n\n    // update energy information\n    const updateEnergy = newVal => {\n      _energy.val = newVal;\n      if (_energy.peak > 0) {\n        _energy.hold--;\n        if (_energy.hold < 0) _energy.peak += _energy.hold * gravity / fpsSquared / canvas.height * this._pixelRatio;\n        // TO-DO: replace `canvas.height * this._pixelRatio` with `maxNominalHeight` when implementing dual-channel energy\n      }\n      if (newVal >= _energy.peak) {\n        _energy.peak = newVal;\n        _energy.hold = holdFrames;\n      }\n    };\n\n    /* MAIN FUNCTION */\n\n    if (overlay) _ctx.clearRect(0, 0, canvas.width, canvas.height);\n    let currentEnergy = 0;\n    const nBars = _bars.length,\n      nChannels = isSingle ? 1 : 2;\n    for (let channel = 0; channel < nChannels; channel++) {\n      const {\n          channelTop,\n          channelBottom,\n          analyzerBottom\n        } = channelCoords[channel],\n        channelGradient = this._gradients[this._selectedGrads[channel]],\n        colorStops = channelGradient.colorStops,\n        colorCount = colorStops.length,\n        bgColor = !showBgColor || isLeds && !overlay ? '#000' : channelGradient.bgColor,\n        radialDirection = isDualVertical && _radial && channel ? -1 : 1,\n        // 1 = outwards, -1 = inwards\n        invertedChannel = !channel && _mirror == -1 || channel && _mirror == 1,\n        radialOffsetX = !isDualHorizontal || channel && _mirror != 1 ? 0 : analyzerWidth >> (channel || !invertedChannel),\n        angularDirection = isDualHorizontal && invertedChannel ? -1 : 1; // 1 = clockwise, -1 = counterclockwise\n      /*\r\n      \t\t\tExpanded logic for radialOffsetX and angularDirection:\r\n      \r\n      \t\t\tlet radialOffsetX = 0,\r\n      \t\t\t\tangularDirection = 1;\r\n      \r\n      \t\t\tif ( isDualHorizontal ) {\r\n      \t\t\t\tif ( channel == 0 ) { // LEFT channel\r\n      \t\t\t\t\tif ( _mirror == -1 ) {\r\n      \t\t\t\t\t\tradialOffsetX = analyzerWidth;\r\n      \t\t\t\t\t\tangularDirection = -1;\r\n      \t\t\t\t\t}\r\n      \t\t\t\t\telse\r\n      \t\t\t\t\t\tradialOffsetX = analyzerWidth >> 1;\r\n      \t\t\t\t}\r\n      \t\t\t\telse {                // RIGHT channel\r\n      \t\t\t\t\tif ( _mirror == 1 ) {\r\n      \t\t\t\t\t\tradialOffsetX = analyzerWidth >> 1;\r\n      \t\t\t\t\t\tangularDirection = -1;\r\n      \t\t\t\t\t}\r\n      \t\t\t\t}\r\n      \t\t\t}\r\n      */\n      // draw scale on Y-axis (uses: channel, channelTop)\n      const drawScaleY = () => {\n        const scaleWidth = canvasX.height,\n          fontSize = scaleWidth >> 1,\n          max = _linearAmplitude ? 100 : maxDecibels,\n          min = _linearAmplitude ? 0 : minDecibels,\n          incr = _linearAmplitude ? 20 : 5,\n          interval = analyzerHeight / (max - min),\n          atStart = _mirror != -1 && (!isDualHorizontal || channel == 0 || _mirror == 1),\n          atEnd = _mirror != 1 && (!isDualHorizontal || channel != _mirror);\n        _ctx.save();\n        _ctx.fillStyle = SCALEY_LABEL_COLOR;\n        _ctx.font = `${fontSize}px ${FONT_FAMILY}`;\n        _ctx.textAlign = 'right';\n        _ctx.lineWidth = 1;\n        for (let val = max; val > min; val -= incr) {\n          const posY = channelTop + (max - val) * interval,\n            even = val % 2 == 0 | 0;\n          if (even) {\n            const labelY = posY + fontSize * (posY == channelTop ? .8 : .35);\n            if (atStart) _ctx.fillText(val, scaleWidth * .85, labelY);\n            if (atEnd) _ctx.fillText(val, (isDualHorizontal ? analyzerWidth : canvas.width) - scaleWidth * .1, labelY);\n            _ctx.strokeStyle = SCALEY_LABEL_COLOR;\n            _ctx.setLineDash([2, 4]);\n            _ctx.lineDashOffset = 0;\n          } else {\n            _ctx.strokeStyle = SCALEY_MIDLINE_COLOR;\n            _ctx.setLineDash([2, 8]);\n            _ctx.lineDashOffset = 1;\n          }\n          _ctx.beginPath();\n          _ctx.moveTo(initialX + scaleWidth * even * atStart, ~~posY + .5); // for sharp 1px line (https://stackoverflow.com/a/13879402/2370385)\n          _ctx.lineTo(finalX - scaleWidth * even * atEnd, ~~posY + .5);\n          _ctx.stroke();\n        }\n        _ctx.restore();\n      };\n\n      // FFT bin data interpolation (uses fftData)\n      const interpolate = (bin, ratio) => {\n        const value = fftData[bin] + (bin < fftData.length - 1 ? (fftData[bin + 1] - fftData[bin]) * ratio : 0);\n        return isNaN(value) ? -Infinity : value;\n      };\n\n      // converts a given X-coordinate to its corresponding angle in radial mode (uses angularDirection)\n      const getAngle = (x, dir = angularDirection) => dir * TAU * ((x + radialOffsetX) / canvas.width) + this._spinAngle;\n\n      // converts planar X,Y coordinates to radial coordinates (uses: getAngle(), radialDirection)\n      const radialXY = (x, y, dir) => {\n        const height = innerRadius + y * radialDirection,\n          angle = getAngle(x, dir);\n        return [centerX + height * Math.cos(angle), centerY + height * Math.sin(angle)];\n      };\n\n      // draws a polygon of width `w` and height `h` at (x,y) in radial mode (uses: angularDirection, radialDirection)\n      const radialPoly = (x, y, w, h, stroke) => {\n        _ctx.beginPath();\n        for (const dir of _mirror && !isDualHorizontal ? [1, -1] : [angularDirection]) {\n          const [startAngle, endAngle] = isRound ? [getAngle(x, dir), getAngle(x + w, dir)] : [];\n          _ctx.moveTo(...radialXY(x, y, dir));\n          _ctx.lineTo(...radialXY(x, y + h, dir));\n          if (isRound) _ctx.arc(centerX, centerY, innerRadius + (y + h) * radialDirection, startAngle, endAngle, dir != 1);else _ctx.lineTo(...radialXY(x + w, y + h, dir));\n          _ctx.lineTo(...radialXY(x + w, y, dir));\n          if (isRound && !stroke)\n            // close the bottom line only when not in outline mode\n            _ctx.arc(centerX, centerY, innerRadius + y * radialDirection, endAngle, startAngle, dir == 1);\n        }\n        strokeIf(stroke);\n        _ctx.fill();\n      };\n\n      // set fillStyle and strokeStyle according to current colorMode (uses: channel, colorStops, colorCount)\n      const setBarColor = (value = 0, barIndex = 0) => {\n        let color;\n        // for graph mode, always use the channel gradient (ignore colorMode)\n        if (_colorMode == COLOR_GRADIENT && !isTrueLeds || _mode == MODE_GRAPH) color = _canvasGradients[channel];else {\n          const selectedIndex = _colorMode == COLOR_BAR_INDEX ? barIndex % colorCount : colorStops.findLastIndex(item => isLeds ? ledPosY(value) <= ledPosY(item.level) : value <= item.level);\n          color = colorStops[selectedIndex].color;\n        }\n        _ctx.fillStyle = _ctx.strokeStyle = color;\n      };\n\n      // CHANNEL START\n\n      if (useCanvas) {\n        // set transform (horizontal flip and translation) for dual-horizontal layout\n        if (isDualHorizontal && !_radial) {\n          const translateX = analyzerWidth * (channel + invertedChannel),\n            flipX = invertedChannel ? -1 : 1;\n          _ctx.setTransform(flipX, 0, 0, 1, translateX, 0);\n        }\n\n        // fill the analyzer background if needed (not overlay or overlay + showBgColor)\n        if (!overlay || showBgColor) {\n          if (overlay) _ctx.globalAlpha = this.bgAlpha;\n          _ctx.fillStyle = bgColor;\n\n          // exclude the reflection area when overlay is true and reflexAlpha == 1 (avoids alpha over alpha difference, in case bgAlpha < 1)\n          if (channel == 0 || !_radial && !isDualCombined) _ctx.fillRect(initialX, channelTop - channelGap, analyzerWidth, (overlay && this.reflexAlpha == 1 ? analyzerHeight : channelHeight) + channelGap);\n          _ctx.globalAlpha = 1;\n        }\n\n        // draw dB scale (Y-axis) - avoid drawing it twice on 'dual-combined' channel layout\n        if (this.showScaleY && !isLumi && !_radial && (channel == 0 || !isDualCombined)) drawScaleY();\n\n        // set line width and dash for LEDs effect\n        if (isLeds) {\n          _ctx.setLineDash([ledHeight, ledSpaceV]);\n          _ctx.lineWidth = _bars[0].width;\n        } else\n          // for outline effect ensure linewidth is not greater than half the bar width\n          _ctx.lineWidth = isOutline ? Math.min(_lineWidth, _bars[0].width / 2) : _lineWidth;\n\n        // set clipping region\n        _ctx.save();\n        if (!_radial) {\n          const region = new Path2D();\n          region.rect(0, channelTop, canvas.width, analyzerHeight);\n          _ctx.clip(region);\n        }\n      } // if ( useCanvas )\n\n      // get a new array of data from the FFT\n      let fftData = this._fftData[channel];\n      this._analyzer[channel].getFloatFrequencyData(fftData);\n\n      // apply weighting\n      if (_weightingFilter) fftData = fftData.map((val, idx) => val + weightingdB(this._binToFreq(idx)));\n\n      // start drawing path (for graph mode)\n      _ctx.beginPath();\n\n      // store line graph points to create mirror effect in radial mode\n      let points = [];\n\n      // draw bars / lines\n\n      for (let barIndex = 0; barIndex < nBars; barIndex++) {\n        const bar = _bars[barIndex],\n          {\n            posX,\n            barCenter,\n            width,\n            freq,\n            binLo,\n            binHi,\n            ratioLo,\n            ratioHi\n          } = bar;\n        let barValue = Math.max(interpolate(binLo, ratioLo), interpolate(binHi, ratioHi));\n\n        // check additional bins (if any) for this bar and keep the highest value\n        for (let j = binLo + 1; j < binHi; j++) {\n          if (fftData[j] > barValue) barValue = fftData[j];\n        }\n\n        // normalize bar amplitude in [0;1] range\n        barValue = this._normalizedB(barValue);\n        bar.value[channel] = barValue;\n        currentEnergy += barValue;\n\n        // update bar peak\n        if (bar.peak[channel] > 0 && bar.alpha[channel] > 0) {\n          bar.hold[channel]--;\n          // if hold is negative, start peak drop or fade out\n          if (bar.hold[channel] < 0) {\n            if (_fadePeaks && !showPeakLine) {\n              const initialAlpha = !isAlpha || isOutline && _lineWidth > 0 ? 1 : isAlpha ? bar.peak[channel] : fillAlpha;\n              bar.alpha[channel] = initialAlpha * (1 + bar.hold[channel] / fadeFrames); // hold is negative, so this is <= 1\n            } else bar.peak[channel] += bar.hold[channel] * gravity / fpsSquared / nominalMaxHeight;\n            // make sure the peak value is reset when using fadePeaks\n            if (bar.alpha[channel] <= 0) bar.peak[channel] = 0;\n          }\n        }\n\n        // check if it's a new peak for this bar\n        if (barValue >= bar.peak[channel]) {\n          bar.peak[channel] = barValue;\n          bar.hold[channel] = holdFrames;\n          // check whether isAlpha or isOutline are active to start the peak alpha with the proper value\n          bar.alpha[channel] = !isAlpha || isOutline && _lineWidth > 0 ? 1 : isAlpha ? barValue : fillAlpha;\n        }\n\n        // if not using the canvas, move earlier to the next bar\n        if (!useCanvas) continue;\n\n        // set opacity for bar effects\n        _ctx.globalAlpha = isLumi || isAlpha ? barValue : isOutline ? fillAlpha : 1;\n\n        // set fillStyle and strokeStyle for the current bar\n        setBarColor(barValue, barIndex);\n\n        // compute actual bar height on screen\n        const barHeight = isLumi ? maxBarHeight : isLeds ? ledPosY(barValue) : barValue * maxBarHeight | 0;\n\n        // Draw current bar or line segment\n\n        if (_mode == MODE_GRAPH) {\n          // compute the average between the initial bar (barIndex==0) and the next one\n          // used to smooth the curve when the initial posX is off the screen, in mirror and radial modes\n          const nextBarAvg = barIndex ? 0 : (this._normalizedB(fftData[_bars[1].binLo]) * maxBarHeight + barHeight) / 2;\n          if (_radial) {\n            if (barIndex == 0) {\n              if (isDualHorizontal) _ctx.moveTo(...radialXY(0, 0));\n              _ctx.lineTo(...radialXY(0, posX < 0 ? nextBarAvg : barHeight));\n            }\n            // draw line to the current point, avoiding overlapping wrap-around frequencies\n            if (posX >= 0) {\n              const point = [posX, barHeight];\n              _ctx.lineTo(...radialXY(...point));\n              points.push(point);\n            }\n          } else {\n            // Linear\n            if (barIndex == 0) {\n              // start the line off-screen using the previous FFT bin value as the initial amplitude\n              if (_mirror == -1 && !isDualHorizontal) _ctx.moveTo(initialX, analyzerBottom - (posX < initialX ? nextBarAvg : barHeight));else {\n                const prevFFTData = binLo ? this._normalizedB(fftData[binLo - 1]) * maxBarHeight : barHeight; // use previous FFT bin value, when available\n                _ctx.moveTo(initialX - _lineWidth, analyzerBottom - prevFFTData);\n              }\n            }\n            // draw line to the current point\n            // avoid X values lower than the origin when mirroring left, otherwise draw them for best graph accuracy\n            if (isDualHorizontal || _mirror != -1 || posX >= initialX) _ctx.lineTo(posX, analyzerBottom - barHeight);\n          }\n        } else {\n          if (isLeds) {\n            // draw \"unlit\" leds - avoid drawing it twice on 'dual-combined' channel layout\n            if (showBgColor && !overlay && (channel == 0 || !isDualCombined)) {\n              const alpha = _ctx.globalAlpha;\n              _ctx.strokeStyle = LEDS_UNLIT_COLOR;\n              _ctx.globalAlpha = 1;\n              strokeBar(barCenter, channelTop, analyzerBottom);\n              // restore properties\n              _ctx.strokeStyle = _ctx.fillStyle;\n              _ctx.globalAlpha = alpha;\n            }\n            if (isTrueLeds) {\n              // ledPosY() is used below to fit one entire led height into the selected range\n              const colorIndex = isLumi ? 0 : colorStops.findLastIndex(item => ledPosY(barValue) <= ledPosY(item.level));\n              let last = analyzerBottom;\n              for (let i = colorCount - 1; i >= colorIndex; i--) {\n                _ctx.strokeStyle = colorStops[i].color;\n                let y = analyzerBottom - (i == colorIndex ? barHeight : ledPosY(colorStops[i].level));\n                strokeBar(barCenter, last, y);\n                last = y - ledSpaceV;\n              }\n            } else strokeBar(barCenter, analyzerBottom, analyzerBottom - barHeight);\n          } else if (posX >= initialX) {\n            if (_radial) radialPoly(posX, 0, width, barHeight, isOutline);else if (isRound) {\n              const halfWidth = width / 2,\n                y = analyzerBottom + halfWidth; // round caps have an additional height of half bar width\n\n              _ctx.beginPath();\n              _ctx.moveTo(posX, y);\n              _ctx.lineTo(posX, y - barHeight);\n              _ctx.arc(barCenter, y - barHeight, halfWidth, PI, TAU);\n              _ctx.lineTo(posX + width, y);\n              strokeIf(isOutline);\n              _ctx.fill();\n            } else {\n              const offset = isOutline ? _ctx.lineWidth : 0;\n              _ctx.beginPath();\n              _ctx.rect(posX, analyzerBottom + offset, width, -barHeight - offset);\n              strokeIf(isOutline);\n              _ctx.fill();\n            }\n          }\n        }\n\n        // Draw peak\n        const peakValue = bar.peak[channel],\n          peakAlpha = bar.alpha[channel];\n        if (peakValue > 0 && peakAlpha > 0 && showPeaks && !showPeakLine && !isLumi && posX >= initialX && posX < finalX) {\n          // set opacity for peak\n          if (_fadePeaks) _ctx.globalAlpha = peakAlpha;else if (isOutline && _lineWidth > 0)\n            // when lineWidth == 0 ctx.globalAlpha remains set to `fillAlpha`\n            _ctx.globalAlpha = 1;else if (isAlpha)\n            // isAlpha (alpha based on peak value) supersedes fillAlpha if lineWidth == 0\n            _ctx.globalAlpha = peakValue;\n\n          // select the peak color for 'bar-level' colorMode or 'trueLeds'\n          if (_colorMode == COLOR_BAR_LEVEL || isTrueLeds) setBarColor(peakValue);\n\n          // render peak according to current mode / effect\n          if (isLeds) {\n            const ledPeak = ledPosY(peakValue);\n            if (ledPeak >= ledSpaceV)\n              // avoid peak below first led\n              _ctx.fillRect(posX, analyzerBottom - ledPeak, width, ledHeight);\n          } else if (!_radial) _ctx.fillRect(posX, analyzerBottom - peakValue * maxBarHeight, width, 2);else if (_mode != MODE_GRAPH) {\n            // radial (peaks for graph mode are done by the peakLine code)\n            const y = peakValue * maxBarHeight;\n            radialPoly(posX, y, width, !this._radialInvert || isDualVertical || y + innerRadius >= 2 ? -2 : 2);\n          }\n        }\n      } // for ( let barIndex = 0; barIndex < nBars; barIndex++ )\n\n      // if not using the canvas, move earlier to the next channel\n      if (!useCanvas) continue;\n\n      // restore global alpha\n      _ctx.globalAlpha = 1;\n\n      // Fill/stroke drawing path for graph mode\n      if (_mode == MODE_GRAPH) {\n        setBarColor(); // select channel gradient\n\n        if (_radial && !isDualHorizontal) {\n          if (_mirror) {\n            let p;\n            while (p = points.pop()) _ctx.lineTo(...radialXY(...p, -1));\n          }\n          _ctx.closePath();\n        }\n        if (_lineWidth > 0) _ctx.stroke();\n        if (fillAlpha > 0) {\n          if (_radial) {\n            // exclude the center circle from the fill area\n            const start = isDualHorizontal ? getAngle(analyzerWidth >> 1) : 0,\n              end = isDualHorizontal ? getAngle(analyzerWidth) : TAU;\n            _ctx.moveTo(...radialXY(isDualHorizontal ? analyzerWidth >> 1 : 0, 0));\n            _ctx.arc(centerX, centerY, innerRadius, start, end, isDualHorizontal ? !invertedChannel : true);\n          } else {\n            // close the fill area\n            _ctx.lineTo(finalX, analyzerBottom);\n            _ctx.lineTo(initialX, analyzerBottom);\n          }\n          _ctx.globalAlpha = fillAlpha;\n          _ctx.fill();\n          _ctx.globalAlpha = 1;\n        }\n\n        // draw peak line (and standard peaks on radial)\n        if (showPeakLine || _radial && showPeaks) {\n          points = []; // for mirror line on radial\n          _ctx.beginPath();\n          _bars.forEach((b, i) => {\n            let x = b.posX,\n              h = b.peak[channel],\n              m = i ? 'lineTo' : 'moveTo';\n            if (_radial && x < 0) {\n              const nextBar = _bars[i + 1];\n              h = findY(x, h, nextBar.posX, nextBar.peak[channel], 0);\n              x = 0;\n            }\n            h *= maxBarHeight;\n            if (showPeakLine) {\n              _ctx[m](...(_radial ? radialXY(x, h) : [x, analyzerBottom - h]));\n              if (_radial && _mirror && !isDualHorizontal) points.push([x, h]);\n            } else if (h > 0) radialPoly(x, h, 1, -2); // standard peaks (also does mirror)\n          });\n          if (showPeakLine) {\n            let p;\n            while (p = points.pop()) _ctx.lineTo(...radialXY(...p, -1)); // mirror line points\n            _ctx.lineWidth = 1;\n            _ctx.stroke(); // stroke peak line\n          }\n        }\n      }\n      _ctx.restore(); // restore clip region\n\n      if (isDualHorizontal && !_radial) _ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n      // create Reflex effect - for dual-combined and dual-horizontal do it only once, after channel 1\n      if (!isDualHorizontal && !isDualCombined || channel) doReflex(channel);\n    } // for ( let channel = 0; channel < nChannels; channel++ ) {\n\n    updateEnergy(currentEnergy / (nBars << nChannels - 1));\n    if (useCanvas) {\n      // Mirror effect\n      if (_mirror && !_radial && !isDualHorizontal) {\n        _ctx.setTransform(-1, 0, 0, 1, canvas.width - initialX, 0);\n        _ctx.drawImage(canvas, initialX, 0, centerX, canvas.height, 0, 0, centerX, canvas.height);\n        _ctx.setTransform(1, 0, 0, 1, 0, 0);\n      }\n\n      // restore solid lines\n      _ctx.setLineDash([]);\n\n      // draw frequency scale (X-axis)\n      drawScaleX();\n    }\n\n    // display current frame rate\n    if (this.showFPS) {\n      const size = canvasX.height;\n      _ctx.font = `bold ${size}px ${FONT_FAMILY}`;\n      _ctx.fillStyle = FPS_COLOR;\n      _ctx.textAlign = 'right';\n      _ctx.fillText(Math.round(_fps), canvas.width - size, size * 2);\n    }\n\n    // call callback function, if defined\n    if (this.onCanvasDraw) {\n      _ctx.save();\n      _ctx.fillStyle = _ctx.strokeStyle = _canvasGradients[0];\n      this.onCanvasDraw(this, {\n        timestamp,\n        canvasGradients: _canvasGradients\n      });\n      _ctx.restore();\n    }\n  }\n\n  /**\r\n   * Return scaled frequency according to the selected scale\r\n   */\n  _freqScaling(freq) {\n    switch (this._frequencyScale) {\n      case SCALE_LOG:\n        return Math.log2(freq);\n      case SCALE_BARK:\n        return 26.81 * freq / (1960 + freq) - .53;\n      case SCALE_MEL:\n        return Math.log2(1 + freq / 700);\n      case SCALE_LINEAR:\n        return freq;\n    }\n  }\n\n  /**\r\n   * Return the FFT data bin (array index) which represents a given frequency\r\n   */\n  _freqToBin(freq, method = 'round') {\n    const max = this._analyzer[0].frequencyBinCount - 1,\n      bin = Math[method](freq * this.fftSize / this.audioCtx.sampleRate);\n    return bin < max ? bin : max;\n  }\n\n  /**\r\n   * Generate currently selected gradient\r\n   */\n  _makeGrad() {\n    if (!this._ready) return;\n    const {\n        canvas,\n        _ctx,\n        _radial,\n        _reflexRatio\n      } = this,\n      {\n        analyzerWidth,\n        centerX,\n        centerY,\n        initialX,\n        innerRadius,\n        outerRadius\n      } = this._aux,\n      {\n        isLumi\n      } = this._flg,\n      isDualVertical = this._chLayout == CHANNEL_VERTICAL,\n      analyzerRatio = 1 - _reflexRatio,\n      gradientHeight = isLumi ? canvas.height : canvas.height * (1 - _reflexRatio * !isDualVertical) | 0;\n    // for vertical stereo we keep the full canvas height and handle the reflex areas while generating the color stops\n\n    for (const channel of [0, 1]) {\n      const currGradient = this._gradients[this._selectedGrads[channel]],\n        colorStops = currGradient.colorStops,\n        isHorizontal = currGradient.dir == 'h';\n      let grad;\n      if (_radial) grad = _ctx.createRadialGradient(centerX, centerY, outerRadius, centerX, centerY, innerRadius - (outerRadius - innerRadius) * isDualVertical);else grad = _ctx.createLinearGradient(...(isHorizontal ? [initialX, 0, initialX + analyzerWidth, 0] : [0, 0, 0, gradientHeight]));\n      if (colorStops) {\n        const dual = isDualVertical && !this._splitGradient && (!isHorizontal || _radial);\n        for (let channelArea = 0; channelArea < 1 + dual; channelArea++) {\n          const maxIndex = colorStops.length - 1;\n          colorStops.forEach((colorStop, index) => {\n            let offset = colorStop.pos;\n\n            // in dual mode (not split), use half the original offset for each channel\n            if (dual) offset /= 2;\n\n            // constrain the offset within the useful analyzer areas (avoid reflex areas)\n            if (isDualVertical && !isLumi && !_radial && !isHorizontal) {\n              offset *= analyzerRatio;\n              // skip the first reflex area in split mode\n              if (!dual && offset > .5 * analyzerRatio) offset += .5 * _reflexRatio;\n            }\n\n            // only for dual-vertical non-split gradient (creates full gradient on both halves of the canvas)\n            if (channelArea == 1) {\n              // add colors in reverse order if radial or lumi are active\n              if (_radial || isLumi) {\n                const revIndex = maxIndex - index;\n                colorStop = colorStops[revIndex];\n                offset = 1 - colorStop.pos / 2;\n              } else {\n                // if the first offset is not 0, create an additional color stop to prevent bleeding from the first channel\n                if (index == 0 && offset > 0) grad.addColorStop(.5, colorStop.color);\n                // bump the offset to the second half of the gradient\n                offset += .5;\n              }\n            }\n\n            // add gradient color stop\n            grad.addColorStop(offset, colorStop.color);\n\n            // create additional color stop at the end of first channel to prevent bleeding\n            if (isDualVertical && index == maxIndex && offset < .5) grad.addColorStop(.5, colorStop.color);\n          });\n        } // for ( let channelArea = 0; channelArea < 1 + dual; channelArea++ )\n      }\n      this._canvasGradients[channel] = grad;\n    } // for ( const channel of [0,1] )\n  }\n\n  /**\r\n   * Normalize a dB value in the [0;1] range\r\n   */\n  _normalizedB(value) {\n    const isLinear = this._linearAmplitude,\n      boost = isLinear ? 1 / this._linearBoost : 1,\n      clamp = (val, min, max) => val <= min ? min : val >= max ? max : val,\n      dBToLinear = val => 10 ** (val / 20);\n    let maxValue = this.maxDecibels,\n      minValue = this.minDecibels;\n    if (isLinear) {\n      maxValue = dBToLinear(maxValue);\n      minValue = dBToLinear(minValue);\n      value = dBToLinear(value) ** boost;\n    }\n    return clamp((value - minValue) / (maxValue - minValue) ** boost, 0, 1);\n  }\n\n  /**\r\n   * Internal function to change canvas dimensions on demand\r\n   */\n  _setCanvas(reason) {\n    if (!this._ready) return;\n    const {\n        canvas,\n        _ctx\n      } = this,\n      canvasX = this._scaleX.canvas,\n      pixelRatio = window.devicePixelRatio / (this._loRes + 1);\n    let screenWidth = window.screen.width * pixelRatio,\n      screenHeight = window.screen.height * pixelRatio;\n\n    // Fix for iOS Safari - swap width and height when in landscape\n    if (Math.abs(window.orientation) == 90 && screenWidth < screenHeight) [screenWidth, screenHeight] = [screenHeight, screenWidth];\n    const isFullscreen = this.isFullscreen,\n      isCanvasFs = isFullscreen && this._fsEl == canvas,\n      newWidth = isCanvasFs ? screenWidth : (this._width || this._container.clientWidth || this._defaultWidth) * pixelRatio | 0,\n      newHeight = isCanvasFs ? screenHeight : (this._height || this._container.clientHeight || this._defaultHeight) * pixelRatio | 0;\n\n    // set/update object properties\n    this._pixelRatio = pixelRatio;\n    this._fsWidth = screenWidth;\n    this._fsHeight = screenHeight;\n\n    // if this is not the constructor call and canvas dimensions haven't changed, quit\n    if (reason != REASON_CREATE && canvas.width == newWidth && canvas.height == newHeight) return;\n\n    // apply new dimensions\n    canvas.width = newWidth;\n    canvas.height = newHeight;\n\n    // if not in overlay mode, paint the canvas black\n    if (!this.overlay) {\n      _ctx.fillStyle = '#000';\n      _ctx.fillRect(0, 0, newWidth, newHeight);\n    }\n\n    // set lineJoin property for area fill mode (this is reset whenever the canvas size changes)\n    _ctx.lineJoin = 'bevel';\n\n    // update dimensions of the scale canvas\n    canvasX.width = newWidth;\n    canvasX.height = Math.max(20 * pixelRatio, Math.min(newWidth, newHeight) / 32 | 0);\n\n    // calculate bar positions and led options\n    this._calcBars();\n\n    // (re)generate gradient\n    this._makeGrad();\n\n    // detect fullscreen changes (for Safari)\n    if (this._fsStatus !== undefined && this._fsStatus !== isFullscreen) reason = REASON_FSCHANGE;\n    this._fsStatus = isFullscreen;\n\n    // call the callback function, if defined\n    if (this.onCanvasResize) this.onCanvasResize(reason, this);\n  }\n\n  /**\r\n   * Select a gradient for one or both channels\r\n   *\r\n   * @param {string} name gradient name\r\n   * @param [{number}] desired channel (0 or 1) - if empty or invalid, sets both channels\r\n   */\n  _setGradient(name, channel) {\n    if (!this._gradients.hasOwnProperty(name)) throw new AudioMotionError(ERR_UNKNOWN_GRADIENT, name);\n    if (![0, 1].includes(channel)) {\n      this._selectedGrads[1] = name;\n      channel = 0;\n    }\n    this._selectedGrads[channel] = name;\n    this._makeGrad();\n  }\n\n  /**\r\n   * Set object properties\r\n   */\n  _setProps(options, useDefaults) {\n    // callback functions properties\n    const callbacks = ['onCanvasDraw', 'onCanvasResize'];\n\n    // properties not in the defaults (`stereo` is deprecated)\n    const extraProps = ['gradientLeft', 'gradientRight', 'stereo'];\n\n    // build an array of valid properties; `start` is not an actual property and is handled after setting everything else\n    const validProps = Object.keys(DEFAULT_SETTINGS).filter(e => e != 'start').concat(callbacks, extraProps);\n    if (useDefaults || options === undefined) options = {\n      ...DEFAULT_SETTINGS,\n      ...options\n    }; // merge options with defaults\n\n    for (const prop of Object.keys(options)) {\n      if (callbacks.includes(prop) && typeof options[prop] !== 'function')\n        // check invalid callback\n        this[prop] = undefined;else if (validProps.includes(prop))\n        // set only valid properties\n        this[prop] = options[prop];\n    }\n\n    // deprecated - move this to the constructor in the next major release (`start` should be constructor-specific)\n    if (options.start !== undefined) this.toggleAnalyzer(options.start);\n  }\n}\nexport { AudioMotionAnalyzer };\nexport default AudioMotionAnalyzer;","map":{"version":3,"names":["VERSION","PI","Math","TAU","HALF_PI","C_1","CANVAS_BACKGROUND_COLOR","CHANNEL_COMBINED","CHANNEL_HORIZONTAL","CHANNEL_SINGLE","CHANNEL_VERTICAL","COLOR_BAR_INDEX","COLOR_BAR_LEVEL","COLOR_GRADIENT","DEBOUNCE_TIMEOUT","EVENT_CLICK","EVENT_FULLSCREENCHANGE","EVENT_RESIZE","GRADIENT_DEFAULT_BGCOLOR","FILTER_NONE","FILTER_A","FILTER_B","FILTER_C","FILTER_D","FILTER_468","FONT_FAMILY","FPS_COLOR","LEDS_UNLIT_COLOR","MODE_GRAPH","REASON_CREATE","REASON_FSCHANGE","REASON_LORES","REASON_RESIZE","REASON_USER","SCALEX_BACKGROUND_COLOR","SCALEX_LABEL_COLOR","SCALEX_HIGHLIGHT_COLOR","SCALEY_LABEL_COLOR","SCALEY_MIDLINE_COLOR","SCALE_BARK","SCALE_LINEAR","SCALE_LOG","SCALE_MEL","PRISM","GRADIENTS","colorStops","color","level","pos","dir","bgColor","DEFAULT_SETTINGS","alphaBars","ansiBands","barSpace","bgAlpha","channelLayout","colorMode","fadePeaks","fftSize","fillAlpha","frequencyScale","gradient","gravity","height","undefined","ledBars","linearAmplitude","linearBoost","lineWidth","loRes","lumiBars","maxDecibels","maxFPS","maxFreq","minDecibels","minFreq","mirror","mode","noteLabels","outlineBars","overlay","peakFadeTime","peakHoldTime","peakLine","radial","radialInvert","radius","reflexAlpha","reflexBright","reflexFit","reflexRatio","roundBars","showBgColor","showFPS","showPeaks","showScaleX","showScaleY","smoothing","spinSpeed","splitGradient","start","trueLeds","useCanvas","volume","weightingFilter","width","ERR_AUDIO_CONTEXT_FAIL","ERR_INVALID_AUDIO_CONTEXT","ERR_UNKNOWN_GRADIENT","ERR_FREQUENCY_TOO_LOW","ERR_INVALID_MODE","ERR_REFLEX_OUT_OF_RANGE","ERR_INVALID_AUDIO_SOURCE","ERR_GRADIENT_INVALID_NAME","ERR_GRADIENT_NOT_AN_OBJECT","ERR_GRADIENT_MISSING_COLOR","AudioMotionError","Error","constructor","error","value","code","message","name","deprecate","alternative","console","warn","isEmpty","obj","p","validateFromList","list","modifier","max","indexOf","findY","x1","y1","x2","y2","x","Array","prototype","findLastIndex","callback","index","length","AudioMotionAnalyzer","container","options","_ready","_aux","_canvasGradients","_destroyed","_energy","val","peak","hold","_flg","_fps","_gradients","_last","_outNodes","_ownContext","_selectedGrads","_sources","Element","_ownCanvas","canvas","HTMLCanvasElement","document","createElement","style","_ctx","getContext","registerGradient","_container","parentElement","body","_defaultWidth","clientWidth","_defaultHeight","clientHeight","audioCtx","source","context","window","AudioContext","webkitAudioContext","err","createGain","analyzer","_analyzer","createAnalyser","splitter","_splitter","createChannelSplitter","merger","_merger","createChannelMerger","_input","_output","connectInput","i","connect","connectSpeakers","connectOutput","ctx","_fsEl","fsElement","onResize","_fsTimeout","setTimeout","_fsChanging","_setCanvas","ResizeObserver","_observer","observe","_controller","AbortController","signal","addEventListener","clearTimeout","unlockContext","state","resume","removeEventListener","visibilityState","_frames","_time","performance","now","_setProps","appendChild","_alphaBars","_calcBars","_ansiBands","_barSpace","_chLayout","disconnect","_makeGrad","_colorMode","_fadePeaks","binCount","frequencyBinCount","_fftData","Float32Array","_frequencyScale","_setGradient","gradientLeft","gradientRight","_gravity","_height","h","_showLeds","_linearAmplitude","_linearBoost","_lineWidth","_loRes","_lumiBars","_maxFPS","_maxFreq","min","sampleRate","_minFreq","_mirror","sign","_mode","_noteLabels","_createScales","_outlineBars","_peakFadeTime","_peakHoldTime","_peakLine","_radial","_radialInvert","_radius","_reflexRatio","_roundBars","smoothingTimeConstant","_spinSpeed","_spinAngle","_splitGradient","stereo","_trueLeds","gain","_weightingFilter","_width","w","canvasCtx","connectedSources","connectedTo","fps","fsHeight","_fsHeight","fsWidth","_fsWidth","isAlphaBars","isAlpha","isBandsMode","isBands","isDestroyed","isFullscreen","fullscreenElement","webkitFullscreenElement","isLedBars","isLeds","isLumiBars","isLumi","isOctaveBands","isOctaves","isOn","_runId","isOutlineBars","isOutline","pixelRatio","_pixelRatio","isRoundBars","isRound","version","isHTML","HTMLMediaElement","node","createMediaElementSource","includes","push","destination","destroy","stop","abort","onCanvasResize","onCanvasDraw","disconnectInput","disconnectOutput","close","remove","sources","stopTracks","from","isArray","idx","mediaStream","track","getAudioTracks","splice","filter","e","getBars","_bars","posX","freq","freqLo","freqHi","getEnergy","startFreq","endFreq","presets","bass","lowMid","mid","highMid","treble","startBin","_freqToBin","endBin","chnCount","energy","channel","_normalizedB","getOptions","ignore","prop","Object","keys","trim","count","isInvalid","forEach","colorStop","sort","a","b","setCanvasSize","setFreqRange","setLedParams","params","maxLeds","spaceV","spaceH","_ledParams","setOptions","setSensitivity","toggleAnalyzer","force","hasStarted","cancelAnimationFrame","requestAnimationFrame","timestamp","_draw","toggleFullscreen","exitFullscreen","webkitExitFullscreen","fsEl","requestFullscreen","webkitRequestFullscreen","_binToFreq","bin","bars","noLedGap","centerX","centerY","isDualVertical","isDualHorizontal","channelHeight","analyzerHeight","analyzerWidth","channelGap","initialX","innerRadius","outerRadius","barsPush","args","alpha","calcRatio","lower","upper","ratio","log2","barWidth","scaleMin","unitWidth","roundSD","digits","atLeast","toPrecision","log10","nearestPreferred","preferred","power","normalized","bands","bandWidth","halfBand","analyzerBars","currFreq","binLo","ratioLo","binHi","ratioHi","toString","bar","firstBar","lastBar","_freqScaling","invFreqScaling","minIndex","maxIndex","lastPos","round","dPR","devicePixelRatio","screen","customParams","spaceVRatio","spaceHRatio","ledCount","maxHeight","minHeight","blockHeight","refRatio","_leds","barSpacePx","barCenter","channelCoords","channelTop","channelBottom","analyzerBottom","_scaleX","_scaleR","canvasX","canvasR","freqLabels","minDimension","scale","scaleHeight","fontSizeX","fontSizeR","labelWidthX","labelWidthR","root12","octave","note","pitch","isC","centerR","radialY","radialLabel","label","angle","adjAng","cos","posY","sin","save","translate","rotate","fillText","restore","fillStyle","strokeStyle","fillRect","arc","stroke","font","textAlign","prevX","prevR","item","y","maxW","isLog","isLinear","allowedLabels","measureText","elapsed","frameTime","targetInterval","fadeFrames","fpsSquared","holdFrames","isDualCombined","isSingle","isTrueLeds","finalX","showPeakLine","maxBarHeight","nominalMaxHeight","dbRange","ledSpaceH","ledSpaceV","ledHeight","doReflex","globalAlpha","setTransform","drawImage","drawScaleX","weightingdB","f2","SQ20_6","SQ107_7","SQ158_5","SQ737_9","SQ12194","linearTodB","rA","sqrt","rB","rC","rD","h1","h2","rI","hypot","strokeBar","beginPath","moveTo","lineTo","strokeIf","flag","ledPosY","updateEnergy","newVal","clearRect","currentEnergy","nBars","nChannels","channelGradient","colorCount","radialDirection","invertedChannel","radialOffsetX","angularDirection","drawScaleY","scaleWidth","fontSize","incr","interval","atStart","atEnd","even","labelY","setLineDash","lineDashOffset","interpolate","fftData","isNaN","Infinity","getAngle","radialXY","radialPoly","startAngle","endAngle","fill","setBarColor","barIndex","selectedIndex","translateX","flipX","region","Path2D","rect","clip","getFloatFrequencyData","map","points","barValue","j","initialAlpha","barHeight","nextBarAvg","point","prevFFTData","colorIndex","last","halfWidth","offset","peakValue","peakAlpha","ledPeak","pop","closePath","end","m","nextBar","size","canvasGradients","method","analyzerRatio","gradientHeight","currGradient","isHorizontal","grad","createRadialGradient","createLinearGradient","dual","channelArea","revIndex","addColorStop","boost","clamp","dBToLinear","maxValue","minValue","reason","screenWidth","screenHeight","abs","orientation","isCanvasFs","newWidth","newHeight","lineJoin","_fsStatus","hasOwnProperty","useDefaults","callbacks","extraProps","validProps","concat"],"sources":["C:/Users/User/OneDrive/Documents/Projects/lecture-summarizer-web-ai/node_modules/audiomotion-analyzer/src/audioMotion-analyzer.js"],"sourcesContent":["/**!\r\n * audioMotion-analyzer\r\n * High-resolution real-time graphic audio spectrum analyzer JS module\r\n *\r\n * @version 4.5.0\r\n * @author  Henrique Avila Vianna <hvianna@gmail.com> <https://henriquevianna.com>\r\n * @license AGPL-3.0-or-later\r\n */\r\n\r\nconst VERSION = '4.5.0';\r\n\r\n// internal constants\r\nconst PI      = Math.PI,\r\n\t  TAU     = 2 * PI,\r\n\t  HALF_PI = PI / 2,\r\n\t  C_1     = 8.17579892;  // frequency for C -1\r\n\r\nconst CANVAS_BACKGROUND_COLOR  = '#000',\r\n\t  CHANNEL_COMBINED         = 'dual-combined',\r\n\t  CHANNEL_HORIZONTAL       = 'dual-horizontal',\r\n\t  CHANNEL_SINGLE           = 'single',\r\n\t  CHANNEL_VERTICAL         = 'dual-vertical',\r\n\t  COLOR_BAR_INDEX          = 'bar-index',\r\n\t  COLOR_BAR_LEVEL          = 'bar-level',\r\n\t  COLOR_GRADIENT           = 'gradient',\r\n\t  DEBOUNCE_TIMEOUT         = 60,\r\n\t  EVENT_CLICK              = 'click',\r\n\t  EVENT_FULLSCREENCHANGE   = 'fullscreenchange',\r\n\t  EVENT_RESIZE             = 'resize',\r\n \t  GRADIENT_DEFAULT_BGCOLOR = '#111',\r\n \t  FILTER_NONE              = '',\r\n \t  FILTER_A                 = 'A',\r\n \t  FILTER_B                 = 'B',\r\n \t  FILTER_C                 = 'C',\r\n \t  FILTER_D                 = 'D',\r\n \t  FILTER_468               = '468',\r\n\t  FONT_FAMILY              = 'sans-serif',\r\n\t  FPS_COLOR                = '#0f0',\r\n\t  LEDS_UNLIT_COLOR         = '#7f7f7f22',\r\n\t  MODE_GRAPH               = 10,\r\n\t  REASON_CREATE            = 'create',\r\n\t  REASON_FSCHANGE          = 'fschange',\r\n\t  REASON_LORES             = 'lores',\r\n\t  REASON_RESIZE            = EVENT_RESIZE,\r\n\t  REASON_USER              = 'user',\r\n\t  SCALEX_BACKGROUND_COLOR  = '#000c',\r\n\t  SCALEX_LABEL_COLOR       = '#fff',\r\n\t  SCALEX_HIGHLIGHT_COLOR   = '#4f4',\r\n\t  SCALEY_LABEL_COLOR       = '#888',\r\n\t  SCALEY_MIDLINE_COLOR     = '#555',\r\n\t  SCALE_BARK               = 'bark',\r\n\t  SCALE_LINEAR             = 'linear',\r\n\t  SCALE_LOG                = 'log',\r\n\t  SCALE_MEL                = 'mel';\r\n\r\n// built-in gradients\r\nconst PRISM = [ '#a35', '#c66', '#e94', '#ed0', '#9d5', '#4d8', '#2cb', '#0bc', '#09c', '#36b' ],\r\n\t  GRADIENTS = [\r\n\t  [ 'classic', {\r\n\t\t\tcolorStops: [\r\n\t\t\t\t'red',\r\n\t\t\t\t{ color: 'yellow', level: .85, pos: .6 },\r\n\t\t\t\t{ color: 'lime', level: .475 }\r\n\t\t\t]\r\n\t  }],\r\n\t  [ 'prism', {\r\n\t\t\tcolorStops: PRISM\r\n\t  }],\r\n\t  [ 'rainbow', {\r\n\t\t\tdir: 'h',\r\n\t\t\tcolorStops: [ '#817', ...PRISM, '#639' ]\r\n\t  }],\r\n\t  [ 'orangered', {\r\n\t  \t\tbgColor: '#3e2f29',\r\n\t  \t\tcolorStops: [ 'OrangeRed' ]\r\n\t  }],\r\n\t  [ 'steelblue', {\r\n\t  \t\tbgColor: '#222c35',\r\n\t  \t\tcolorStops: [ 'SteelBlue' ]\r\n\t  }]\r\n];\r\n\r\n// settings defaults\r\nconst DEFAULT_SETTINGS = {\r\n\talphaBars      : false,\r\n\tansiBands      : false,\r\n\tbarSpace       : 0.1,\r\n\tbgAlpha        : 0.7,\r\n\tchannelLayout  : CHANNEL_SINGLE,\r\n\tcolorMode      : COLOR_GRADIENT,\r\n\tfadePeaks      : false,\r\n\tfftSize        : 8192,\r\n\tfillAlpha      : 1,\r\n\tfrequencyScale : SCALE_LOG,\r\n\tgradient       : GRADIENTS[0][0],\r\n\tgravity        : 3.8,\r\n\theight         : undefined,\r\n\tledBars        : false,\r\n\tlinearAmplitude: false,\r\n\tlinearBoost    : 1,\r\n\tlineWidth      : 0,\r\n\tloRes          : false,\r\n\tlumiBars       : false,\r\n\tmaxDecibels    : -25,\r\n\tmaxFPS         : 0,\r\n\tmaxFreq        : 22000,\r\n\tminDecibels    : -85,\r\n\tminFreq        : 20,\r\n\tmirror         : 0,\r\n\tmode           : 0,\r\n\tnoteLabels     : false,\r\n\toutlineBars    : false,\r\n\toverlay        : false,\r\n\tpeakFadeTime   : 750,\r\n\tpeakHoldTime   : 500,\r\n\tpeakLine       : false,\r\n\tradial\t\t   : false,\r\n\tradialInvert   : false,\r\n\tradius         : 0.3,\r\n\treflexAlpha    : 0.15,\r\n\treflexBright   : 1,\r\n\treflexFit      : true,\r\n\treflexRatio    : 0,\r\n\troundBars      : false,\r\n\tshowBgColor    : true,\r\n\tshowFPS        : false,\r\n\tshowPeaks      : true,\r\n\tshowScaleX     : true,\r\n\tshowScaleY     : false,\r\n\tsmoothing      : 0.5,\r\n\tspinSpeed      : 0,\r\n\tsplitGradient  : false,\r\n\tstart          : true,\r\n\ttrueLeds       : false,\r\n\tuseCanvas      : true,\r\n\tvolume         : 1,\r\n\tweightingFilter: FILTER_NONE,\r\n\twidth          : undefined\r\n};\r\n\r\n// custom error messages\r\nconst ERR_AUDIO_CONTEXT_FAIL     = [ 'ERR_AUDIO_CONTEXT_FAIL', 'Could not create audio context. Web Audio API not supported?' ],\r\n\t  ERR_INVALID_AUDIO_CONTEXT  = [ 'ERR_INVALID_AUDIO_CONTEXT', 'Provided audio context is not valid' ],\r\n\t  ERR_UNKNOWN_GRADIENT       = [ 'ERR_UNKNOWN_GRADIENT', 'Unknown gradient' ],\r\n\t  ERR_FREQUENCY_TOO_LOW      = [ 'ERR_FREQUENCY_TOO_LOW', 'Frequency values must be >= 1' ],\r\n\t  ERR_INVALID_MODE           = [ 'ERR_INVALID_MODE', 'Invalid mode' ],\r\n\t  ERR_REFLEX_OUT_OF_RANGE    = [ 'ERR_REFLEX_OUT_OF_RANGE', 'Reflex ratio must be >= 0 and < 1' ],\r\n\t  ERR_INVALID_AUDIO_SOURCE   = [ 'ERR_INVALID_AUDIO_SOURCE', 'Audio source must be an instance of HTMLMediaElement or AudioNode' ],\r\n\t  ERR_GRADIENT_INVALID_NAME  = [ 'ERR_GRADIENT_INVALID_NAME', 'Gradient name must be a non-empty string' ],\r\n\t  ERR_GRADIENT_NOT_AN_OBJECT = [ 'ERR_GRADIENT_NOT_AN_OBJECT', 'Gradient options must be an object' ],\r\n\t  ERR_GRADIENT_MISSING_COLOR = [ 'ERR_GRADIENT_MISSING_COLOR', 'Gradient colorStops must be a non-empty array' ];\r\n\r\nclass AudioMotionError extends Error {\r\n\tconstructor( error, value ) {\r\n\t\tconst [ code, message ] = error;\r\n\t\tsuper( message + ( value !== undefined ? `: ${value}` : '' ) );\r\n\t\tthis.name = 'AudioMotionError';\r\n\t\tthis.code = code;\r\n\t}\r\n}\r\n\r\n// helper function - output deprecation warning message on console\r\nconst deprecate = ( name, alternative ) => console.warn( `${name} is deprecated. Use ${alternative} instead.` );\r\n\r\n// helper function - check if a given object is empty (also returns `true` on null, undefined or any non-object value)\r\nconst isEmpty = obj => {\r\n\tfor ( const p in obj )\r\n\t\treturn false;\r\n\treturn true;\r\n}\r\n\r\n// helper function - validate a given value with an array of strings (by default, all lowercase)\r\n// returns the validated value, or the first element of `list` if `value` is not found in the array\r\nconst validateFromList = ( value, list, modifier = 'toLowerCase' ) => list[ Math.max( 0, list.indexOf( ( '' + value )[ modifier ]() ) ) ];\r\n\r\n// helper function - find the Y-coordinate of a point located between two other points, given its X-coordinate\r\nconst findY = ( x1, y1, x2, y2, x ) => y1 + ( y2 - y1 ) * ( x - x1 ) / ( x2 - x1 );\r\n\r\n// Polyfill for Array.findLastIndex()\r\nif ( ! Array.prototype.findLastIndex ) {\r\n\tArray.prototype.findLastIndex = function( callback ) {\r\n\t\tlet index = this.length;\r\n\t\twhile ( index-- > 0 ) {\r\n\t\t\tif ( callback( this[ index ] ) )\r\n\t\t\t\treturn index;\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\n// AudioMotionAnalyzer class\r\n\r\nclass AudioMotionAnalyzer {\r\n\r\n/**\r\n * CONSTRUCTOR\r\n *\r\n * @param {object} [container] DOM element where to insert the analyzer; if undefined, uses the document body\r\n * @param {object} [options]\r\n * @returns {object} AudioMotionAnalyzer object\r\n */\r\n\tconstructor( container, options = {} ) {\r\n\r\n\t\tthis._ready = false;\r\n\r\n\t\t// Initialize internal objects\r\n\t\tthis._aux = {};\t\t\t\t// auxiliary variables\r\n\t\tthis._canvasGradients = []; // CanvasGradient objects for channels 0 and 1\r\n\t\tthis._destroyed = false;\r\n\t\tthis._energy = { val: 0, peak: 0, hold: 0 };\r\n\t\tthis._flg = {};\t\t\t\t// flags\r\n\t\tthis._fps = 0;\r\n\t\tthis._gradients = {};       // registered gradients\r\n\t\tthis._last = 0;\t\t\t\t// timestamp of last rendered frame\r\n\t\tthis._outNodes = [];\t\t// output nodes\r\n\t\tthis._ownContext = false;\r\n\t\tthis._selectedGrads = [];   // names of the currently selected gradients for channels 0 and 1\r\n\t\tthis._sources = [];\t\t\t// input nodes\r\n\r\n\t\t// Check if options object passed as first argument\r\n\t\tif ( ! ( container instanceof Element ) ) {\r\n\t\t\tif ( isEmpty( options ) && ! isEmpty( container ) )\r\n\t\t\t\toptions = container;\r\n\t\t\tcontainer = null;\r\n\t\t}\r\n\r\n\t\tthis._ownCanvas = ! ( options.canvas instanceof HTMLCanvasElement );\r\n\r\n\t\t// Create a new canvas or use the one provided by the user\r\n\t\tconst canvas = this._ownCanvas ? document.createElement('canvas') : options.canvas;\r\n\t\tcanvas.style = 'max-width: 100%;';\r\n\t\tthis._ctx = canvas.getContext('2d');\r\n\r\n\t\t// Register built-in gradients\r\n\t\tfor ( const [ name, options ] of GRADIENTS )\r\n\t\t\tthis.registerGradient( name, options );\r\n\r\n\t\t// Set container\r\n\t\tthis._container = container || ( ! this._ownCanvas && canvas.parentElement ) || document.body;\r\n\r\n\t\t// Make sure we have minimal width and height dimensions in case of an inline container\r\n\t\tthis._defaultWidth  = this._container.clientWidth  || 640;\r\n\t\tthis._defaultHeight = this._container.clientHeight || 270;\r\n\r\n\t\t// Use audio context provided by user, or create a new one\r\n\r\n\t\tlet audioCtx;\r\n\r\n\t\tif ( options.source && ( audioCtx = options.source.context ) ) {\r\n\t\t\t// get audioContext from provided source audioNode\r\n\t\t}\r\n\t\telse if ( audioCtx = options.audioCtx ) {\r\n\t\t\t// use audioContext provided by user\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttry {\r\n\t\t\t\taudioCtx = new ( window.AudioContext || window.webkitAudioContext )();\r\n\t\t\t\tthis._ownContext = true;\r\n\t\t\t}\r\n\t\t\tcatch( err ) {\r\n\t\t\t\tthrow new AudioMotionError( ERR_AUDIO_CONTEXT_FAIL );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// make sure audioContext is valid\r\n\t\tif ( ! audioCtx.createGain )\r\n\t\t\tthrow new AudioMotionError( ERR_INVALID_AUDIO_CONTEXT );\r\n\r\n\t\t/*\r\n\t\t\tConnection routing:\r\n\t\t\t===================\r\n\r\n\t\t\tfor dual channel layouts:                +--->  analyzer[0]  ---+\r\n\t\t    \t                                     |                      |\r\n\t\t\t(source) --->  input  --->  splitter  ---+                      +--->  merger  --->  output  ---> (destination)\r\n\t\t    \t                                     |                      |\r\n\t\t        \t                                 +--->  analyzer[1]  ---+\r\n\r\n\t\t\tfor single channel layout:\r\n\r\n\t\t\t(source) --->  input  ----------------------->  analyzer[0]  --------------------->  output  ---> (destination)\r\n\r\n\t\t*/\r\n\r\n\t\t// create the analyzer nodes, channel splitter and merger, and gain nodes for input/output connections\r\n\t\tconst analyzer = this._analyzer = [ audioCtx.createAnalyser(), audioCtx.createAnalyser() ];\r\n\t\tconst splitter = this._splitter = audioCtx.createChannelSplitter(2);\r\n \t\tconst merger   = this._merger   = audioCtx.createChannelMerger(2);\r\n \t\tthis._input    = audioCtx.createGain();\r\n \t\tthis._output   = audioCtx.createGain();\r\n\r\n \t\t// connect audio source if provided in the options\r\n\t\tif ( options.source )\r\n\t\t\tthis.connectInput( options.source );\r\n\r\n \t\t// connect splitter -> analyzers\r\n \t\tfor ( const i of [0,1] )\r\n\t\t\tsplitter.connect( analyzer[ i ], i );\r\n\r\n\t\t// connect merger -> output\r\n\t\tmerger.connect( this._output );\r\n\r\n\t\t// connect output -> destination (speakers)\r\n\t\tif ( options.connectSpeakers !== false )\r\n\t\t\tthis.connectOutput();\r\n\r\n\t\t// create auxiliary canvases for the X-axis and radial scale labels\r\n\t\tfor ( const ctx of [ '_scaleX', '_scaleR' ] )\r\n\t\t\tthis[ ctx ] = document.createElement('canvas').getContext('2d');\r\n\r\n\t\t// set fullscreen element (defaults to canvas)\r\n\t\tthis._fsEl = options.fsElement || canvas;\r\n\r\n\t\t// Update canvas size on container / window resize and fullscreen events\r\n\r\n\t\t// Fullscreen changes are handled quite differently across browsers:\r\n\t\t// 1. Chromium browsers will trigger a `resize` event followed by a `fullscreenchange`\r\n\t\t// 2. Firefox triggers the `fullscreenchange` first and then the `resize`\r\n\t\t// 3. Chrome on Android (TV) won't trigger a `resize` event, only `fullscreenchange`\r\n\t\t// 4. Safari won't trigger `fullscreenchange` events at all, and on iPadOS the `resize`\r\n\t\t//    event is triggered **on the window** only (last tested on iPadOS 14)\r\n\r\n\t\t// helper function for resize events\r\n\t\tconst onResize = () => {\r\n\t\t\tif ( ! this._fsTimeout ) {\r\n\t\t\t\t// delay the resize to prioritize a possible following `fullscreenchange` event\r\n\t\t\t\tthis._fsTimeout = window.setTimeout( () => {\r\n\t\t\t\t\tif ( ! this._fsChanging ) {\r\n\t\t\t\t\t\tthis._setCanvas( REASON_RESIZE );\r\n\t\t\t\t\t\tthis._fsTimeout = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}, DEBOUNCE_TIMEOUT );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if browser supports ResizeObserver, listen for resize on the container\r\n\t\tif ( window.ResizeObserver ) {\r\n\t\t\tthis._observer = new ResizeObserver( onResize );\r\n\t\t\tthis._observer.observe( this._container );\r\n\t\t}\r\n\r\n\t\t// create an AbortController to remove event listeners on destroy()\r\n\t\tthis._controller = new AbortController();\r\n\t\tconst signal = this._controller.signal;\r\n\r\n\t\t// listen for resize events on the window - required for fullscreen on iPadOS\r\n\t\twindow.addEventListener( EVENT_RESIZE, onResize, { signal } );\r\n\r\n\t\t// listen for fullscreenchange events on the canvas - not available on Safari\r\n\t\tcanvas.addEventListener( EVENT_FULLSCREENCHANGE, () => {\r\n\t\t\t// set flag to indicate a fullscreen change in progress\r\n\t\t\tthis._fsChanging = true;\r\n\r\n\t\t\t// if there is a scheduled resize event, clear it\r\n\t\t\tif ( this._fsTimeout )\r\n\t\t\t\twindow.clearTimeout( this._fsTimeout );\r\n\r\n\t\t\t// update the canvas\r\n\t\t\tthis._setCanvas( REASON_FSCHANGE );\r\n\r\n\t\t\t// delay clearing the flag to prevent any shortly following resize event\r\n\t\t\tthis._fsTimeout = window.setTimeout( () => {\r\n\t\t\t\tthis._fsChanging = false;\r\n\t\t\t\tthis._fsTimeout = 0;\r\n\t\t\t}, DEBOUNCE_TIMEOUT );\r\n\t\t}, { signal } );\r\n\r\n\t\t// Resume audio context if in suspended state (browsers' autoplay policy)\r\n\t\tconst unlockContext = () => {\r\n\t\t\tif ( audioCtx.state == 'suspended' )\r\n\t\t\t\taudioCtx.resume();\r\n\t\t\twindow.removeEventListener( EVENT_CLICK, unlockContext );\r\n\t\t}\r\n\t\twindow.addEventListener( EVENT_CLICK, unlockContext );\r\n\r\n\t\t// reset FPS-related variables when window becomes visible (avoid FPS drop due to frames not rendered while hidden)\r\n\t\tdocument.addEventListener( 'visibilitychange', () => {\r\n\t\t\tif ( document.visibilityState != 'hidden' ) {\r\n\t\t\t\tthis._frames = 0;\r\n\t\t\t\tthis._time = performance.now();\r\n\t\t\t}\r\n\t\t}, { signal } );\r\n\r\n\t\t// Set configuration options and use defaults for any missing properties\r\n\t\tthis._setProps( options, true );\r\n\r\n\t\t// Add canvas to the container (only when canvas not provided by user)\r\n\t\tif ( this.useCanvas && this._ownCanvas )\r\n\t\t\tthis._container.appendChild( canvas );\r\n\r\n\t\t// Finish canvas setup\r\n\t\tthis._ready = true;\r\n\t\tthis._setCanvas( REASON_CREATE );\r\n\t}\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t *\r\n\t * PUBLIC PROPERTIES GETTERS AND SETTERS\r\n\t *\r\n\t * ==========================================================================\r\n\t */\r\n\r\n\tget alphaBars() {\r\n\t\treturn this._alphaBars;\r\n\t}\r\n\tset alphaBars( value ) {\r\n\t\tthis._alphaBars = !! value;\r\n\t\tthis._calcBars();\r\n\t}\r\n\r\n\tget ansiBands() {\r\n\t\treturn this._ansiBands;\r\n\t}\r\n\tset ansiBands( value ) {\r\n\t\tthis._ansiBands = !! value;\r\n\t\tthis._calcBars();\r\n\t}\r\n\r\n\tget barSpace() {\r\n\t\treturn this._barSpace;\r\n\t}\r\n\tset barSpace( value ) {\r\n\t\tthis._barSpace = +value || 0;\r\n\t\tthis._calcBars();\r\n\t}\r\n\r\n\tget channelLayout() {\r\n\t\treturn this._chLayout;\r\n\t}\r\n\tset channelLayout( value ) {\r\n\t\tthis._chLayout = validateFromList( value, [ CHANNEL_SINGLE, CHANNEL_HORIZONTAL, CHANNEL_VERTICAL, CHANNEL_COMBINED ] );\r\n\r\n\t\t// update node connections\r\n\t\tthis._input.disconnect();\r\n\t\tthis._input.connect( this._chLayout != CHANNEL_SINGLE ? this._splitter : this._analyzer[0] );\r\n\t\tthis._analyzer[0].disconnect();\r\n\t\tif ( this._outNodes.length ) // connect analyzer only if the output is connected to other nodes\r\n\t\t\tthis._analyzer[0].connect( this._chLayout != CHANNEL_SINGLE ? this._merger : this._output );\r\n\r\n\t\tthis._calcBars();\r\n\t\tthis._makeGrad();\r\n\t}\r\n\r\n\tget colorMode() {\r\n\t\treturn this._colorMode;\r\n\t}\r\n\tset colorMode( value ) {\r\n\t\tthis._colorMode = validateFromList( value, [ COLOR_GRADIENT, COLOR_BAR_INDEX, COLOR_BAR_LEVEL ] );\r\n\t}\r\n\r\n\tget fadePeaks() {\r\n\t\treturn this._fadePeaks;\r\n\t}\r\n\tset fadePeaks( value ) {\r\n\t\tthis._fadePeaks = !! value;\r\n\t}\r\n\r\n\tget fftSize() {\r\n\t\treturn this._analyzer[0].fftSize;\r\n\t}\r\n\tset fftSize( value ) {\r\n\t\tfor ( const i of [0,1] )\r\n\t\t\tthis._analyzer[ i ].fftSize = value;\r\n\t\tconst binCount = this._analyzer[0].frequencyBinCount;\r\n\t\tthis._fftData = [ new Float32Array( binCount ), new Float32Array( binCount ) ];\r\n\t\tthis._calcBars();\r\n\t}\r\n\r\n\tget frequencyScale() {\r\n\t\treturn this._frequencyScale;\r\n\t}\r\n\tset frequencyScale( value ) {\r\n\t\tthis._frequencyScale = validateFromList( value, [ SCALE_LOG, SCALE_BARK, SCALE_MEL, SCALE_LINEAR ] );\r\n\t\tthis._calcBars();\r\n\t}\r\n\r\n\tget gradient() {\r\n\t\treturn this._selectedGrads[0];\r\n\t}\r\n\tset gradient( value ) {\r\n\t\tthis._setGradient( value );\r\n\t}\r\n\r\n\tget gradientLeft() {\r\n\t\treturn this._selectedGrads[0];\r\n\t}\r\n\tset gradientLeft( value ) {\r\n\t\tthis._setGradient( value, 0 );\r\n\t}\r\n\r\n\tget gradientRight() {\r\n\t\treturn this._selectedGrads[1];\r\n\t}\r\n\tset gradientRight( value ) {\r\n\t\tthis._setGradient( value, 1 );\r\n\t}\r\n\r\n\tget gravity() {\r\n\t\treturn this._gravity;\r\n\t}\r\n\tset gravity( value ) {\r\n\t\tthis._gravity = value > 0 ? +value : this._gravity || DEFAULT_SETTINGS.gravity;\r\n\t}\r\n\r\n\tget height() {\r\n\t\treturn this._height;\r\n\t}\r\n\tset height( h ) {\r\n\t\tthis._height = h;\r\n\t\tthis._setCanvas( REASON_USER );\r\n\t}\r\n\r\n\tget ledBars() {\r\n\t\treturn this._showLeds;\r\n\t}\r\n\tset ledBars( value ) {\r\n\t\tthis._showLeds = !! value;\r\n\t\tthis._calcBars();\r\n\t}\r\n\r\n\tget linearAmplitude() {\r\n\t\treturn this._linearAmplitude;\r\n\t}\r\n\tset linearAmplitude( value ) {\r\n\t\tthis._linearAmplitude = !! value;\r\n\t}\r\n\r\n\tget linearBoost() {\r\n\t\treturn this._linearBoost;\r\n\t}\r\n\tset linearBoost( value ) {\r\n\t\tthis._linearBoost = value >= 1 ? +value : 1;\r\n\t}\r\n\r\n\tget lineWidth() {\r\n\t\treturn this._lineWidth;\r\n\t}\r\n\tset lineWidth( value ) {\r\n\t\tthis._lineWidth = +value || 0;\r\n\t}\r\n\r\n\tget loRes() {\r\n\t\treturn this._loRes;\r\n\t}\r\n\tset loRes( value ) {\r\n\t\tthis._loRes = !! value;\r\n\t\tthis._setCanvas( REASON_LORES );\r\n\t}\r\n\r\n\tget lumiBars() {\r\n\t\treturn this._lumiBars;\r\n\t}\r\n\tset lumiBars( value ) {\r\n\t\tthis._lumiBars = !! value;\r\n\t\tthis._calcBars();\r\n\t\tthis._makeGrad();\r\n\t}\r\n\r\n\tget maxDecibels() {\r\n\t\treturn this._analyzer[0].maxDecibels;\r\n\t}\r\n\tset maxDecibels( value ) {\r\n\t\tfor ( const i of [0,1] )\r\n\t\t\tthis._analyzer[ i ].maxDecibels = value;\r\n\t}\r\n\r\n\tget maxFPS() {\r\n\t\treturn this._maxFPS;\r\n\t}\r\n\tset maxFPS( value ) {\r\n\t\tthis._maxFPS = value < 0 ? 0 : +value || 0;\r\n\t}\r\n\r\n\tget maxFreq() {\r\n\t\treturn this._maxFreq;\r\n\t}\r\n\tset maxFreq( value ) {\r\n\t\tif ( value < 1 )\r\n\t\t\tthrow new AudioMotionError( ERR_FREQUENCY_TOO_LOW );\r\n\t\telse {\r\n\t\t\tthis._maxFreq = Math.min( value, this.audioCtx.sampleRate / 2 );\r\n\t\t\tthis._calcBars();\r\n\t\t}\r\n\t}\r\n\r\n\tget minDecibels() {\r\n\t\treturn this._analyzer[0].minDecibels;\r\n\t}\r\n\tset minDecibels( value ) {\r\n\t\tfor ( const i of [0,1] )\r\n\t\t\tthis._analyzer[ i ].minDecibels = value;\r\n\t}\r\n\r\n\tget minFreq() {\r\n\t\treturn this._minFreq;\r\n\t}\r\n\tset minFreq( value ) {\r\n\t\tif ( value < 1 )\r\n\t\t\tthrow new AudioMotionError( ERR_FREQUENCY_TOO_LOW );\r\n\t\telse {\r\n\t\t\tthis._minFreq = +value;\r\n\t\t\tthis._calcBars();\r\n\t\t}\r\n\t}\r\n\r\n\tget mirror() {\r\n\t\treturn this._mirror;\r\n\t}\r\n\tset mirror( value ) {\r\n\t\tthis._mirror = Math.sign( value ) | 0; // ensure only -1, 0 or 1\r\n\t\tthis._calcBars();\r\n\t\tthis._makeGrad();\r\n\t}\r\n\r\n\tget mode() {\r\n\t\treturn this._mode;\r\n\t}\r\n\tset mode( value ) {\r\n\t\tconst mode = value | 0;\r\n\t\tif ( mode >= 0 && mode <= 10 && mode != 9 ) {\r\n\t\t\tthis._mode = mode;\r\n\t\t\tthis._calcBars();\r\n\t\t\tthis._makeGrad();\r\n\t\t}\r\n\t\telse\r\n\t\t\tthrow new AudioMotionError( ERR_INVALID_MODE, value );\r\n\t}\r\n\r\n\tget noteLabels() {\r\n\t\treturn this._noteLabels;\r\n\t}\r\n\tset noteLabels( value ) {\r\n\t\tthis._noteLabels = !! value;\r\n\t\tthis._createScales();\r\n\t}\r\n\r\n\tget outlineBars() {\r\n\t\treturn this._outlineBars;\r\n\t}\r\n\tset outlineBars( value ) {\r\n\t\tthis._outlineBars = !! value;\r\n\t\tthis._calcBars();\r\n\t}\r\n\r\n\tget peakFadeTime() {\r\n\t\treturn this._peakFadeTime;\r\n\t}\r\n\tset peakFadeTime( value ) {\r\n\t\tthis._peakFadeTime = value >= 0 ? +value : this._peakFadeTime || DEFAULT_SETTINGS.peakFadeTime;\r\n\t}\r\n\r\n\tget peakHoldTime() {\r\n\t\treturn this._peakHoldTime;\r\n\t}\r\n\tset peakHoldTime( value ) {\r\n\t\tthis._peakHoldTime = +value || 0;\r\n\t}\r\n\r\n\tget peakLine() {\r\n\t\treturn this._peakLine;\r\n\t}\r\n\tset peakLine( value ) {\r\n\t\tthis._peakLine = !! value;\r\n\t}\r\n\r\n\tget radial() {\r\n\t\treturn this._radial;\r\n\t}\r\n\tset radial( value ) {\r\n\t\tthis._radial = !! value;\r\n\t\tthis._calcBars();\r\n\t\tthis._makeGrad();\r\n\t}\r\n\r\n\tget radialInvert() {\r\n\t\treturn this._radialInvert;\r\n\t}\r\n\tset radialInvert( value ) {\r\n\t\tthis._radialInvert = !! value;\r\n\t\tthis._calcBars();\r\n\t\tthis._makeGrad();\r\n\t}\r\n\r\n\tget radius() {\r\n\t\treturn this._radius;\r\n\t}\r\n\tset radius( value ) {\r\n\t\tthis._radius = +value || 0;\r\n\t\tthis._calcBars();\r\n\t\tthis._makeGrad();\r\n\t}\r\n\r\n\tget reflexRatio() {\r\n\t\treturn this._reflexRatio;\r\n\t}\r\n\tset reflexRatio( value ) {\r\n\t\tvalue = +value || 0;\r\n\t\tif ( value < 0 || value >= 1 )\r\n\t\t\tthrow new AudioMotionError( ERR_REFLEX_OUT_OF_RANGE );\r\n\t\telse {\r\n\t\t\tthis._reflexRatio = value;\r\n\t\t\tthis._calcBars();\r\n\t\t\tthis._makeGrad();\r\n\t\t}\r\n\t}\r\n\r\n\tget roundBars() {\r\n\t\treturn this._roundBars;\r\n\t}\r\n\tset roundBars( value ) {\r\n\t\tthis._roundBars = !! value;\r\n\t\tthis._calcBars();\r\n\t}\r\n\r\n\tget smoothing() {\r\n\t\treturn this._analyzer[0].smoothingTimeConstant;\r\n\t}\r\n\tset smoothing( value ) {\r\n\t\tfor ( const i of [0,1] )\r\n\t\t\tthis._analyzer[ i ].smoothingTimeConstant = value;\r\n\t}\r\n\r\n\tget spinSpeed() {\r\n\t\treturn this._spinSpeed;\r\n\t}\r\n\tset spinSpeed( value ) {\r\n\t\tvalue = +value || 0;\r\n\t\tif ( this._spinSpeed === undefined || value == 0 )\r\n\t\t\tthis._spinAngle = -HALF_PI; // initialize or reset the rotation angle\r\n\t\tthis._spinSpeed = value;\r\n\t}\r\n\r\n\tget splitGradient() {\r\n\t\treturn this._splitGradient;\r\n\t}\r\n\tset splitGradient( value ) {\r\n\t\tthis._splitGradient = !! value;\r\n\t\tthis._makeGrad();\r\n\t}\r\n\r\n\tget stereo() {\r\n\t\tdeprecate( 'stereo', 'channelLayout' );\r\n\t\treturn this._chLayout != CHANNEL_SINGLE;\r\n\t}\r\n\tset stereo( value ) {\r\n\t\tdeprecate( 'stereo', 'channelLayout' );\r\n\t\tthis.channelLayout = value ? CHANNEL_VERTICAL : CHANNEL_SINGLE;\r\n\t}\r\n\r\n\tget trueLeds() {\r\n\t\treturn this._trueLeds;\r\n\t}\r\n\tset trueLeds( value ) {\r\n\t\tthis._trueLeds = !! value;\r\n\t}\r\n\r\n\tget volume() {\r\n\t\treturn this._output.gain.value;\r\n\t}\r\n\tset volume( value ) {\r\n\t\tthis._output.gain.value = value;\r\n\t}\r\n\r\n\tget weightingFilter() {\r\n\t\treturn this._weightingFilter;\r\n\t}\r\n\tset weightingFilter( value ) {\r\n\t\tthis._weightingFilter = validateFromList( value, [ FILTER_NONE, FILTER_A, FILTER_B, FILTER_C, FILTER_D, FILTER_468 ], 'toUpperCase' );\r\n\t}\r\n\r\n\tget width() {\r\n\t\treturn this._width;\r\n\t}\r\n\tset width( w ) {\r\n\t\tthis._width = w;\r\n\t\tthis._setCanvas( REASON_USER );\r\n\t}\r\n\r\n\t// Read only properties\r\n\r\n\tget audioCtx() {\r\n\t\treturn this._input.context;\r\n\t}\r\n\tget canvas() {\r\n\t\treturn this._ctx.canvas;\r\n\t}\r\n\tget canvasCtx() {\r\n\t\treturn this._ctx;\r\n\t}\r\n\tget connectedSources() {\r\n\t\treturn this._sources;\r\n\t}\r\n\tget connectedTo() {\r\n\t\treturn this._outNodes;\r\n\t}\r\n\tget fps() {\r\n\t\treturn this._fps;\r\n\t}\r\n\tget fsHeight() {\r\n\t\treturn this._fsHeight;\r\n\t}\r\n\tget fsWidth() {\r\n\t\treturn this._fsWidth;\r\n\t}\r\n\tget isAlphaBars() {\r\n\t\treturn this._flg.isAlpha;\r\n\t}\r\n\tget isBandsMode() {\r\n\t\treturn this._flg.isBands;\r\n\t}\r\n\tget isDestroyed() {\r\n\t\treturn this._destroyed;\r\n\t}\r\n\tget isFullscreen() {\r\n\t\treturn this._fsEl && ( document.fullscreenElement || document.webkitFullscreenElement ) === this._fsEl;\r\n\t}\r\n\tget isLedBars() {\r\n\t\treturn this._flg.isLeds;\r\n\t}\r\n\tget isLumiBars() {\r\n\t\treturn this._flg.isLumi;\r\n\t}\r\n\tget isOctaveBands() {\r\n\t\treturn this._flg.isOctaves;\r\n\t}\r\n\tget isOn() {\r\n\t\treturn !! this._runId;\r\n\t}\r\n\tget isOutlineBars() {\r\n\t\treturn this._flg.isOutline;\r\n\t}\r\n\tget pixelRatio() {\r\n\t\treturn this._pixelRatio;\r\n\t}\r\n\tget isRoundBars() {\r\n\t\treturn this._flg.isRound;\r\n\t}\r\n\tstatic get version() {\r\n\t\treturn VERSION;\r\n\t}\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n     *\r\n\t * PUBLIC METHODS\r\n\t *\r\n\t * ==========================================================================\r\n\t */\r\n\r\n\t/**\r\n\t * Connects an HTML media element or audio node to the analyzer\r\n\t *\r\n\t * @param {object} an instance of HTMLMediaElement or AudioNode\r\n\t * @returns {object} a MediaElementAudioSourceNode object if created from HTML element, or the same input object otherwise\r\n\t */\r\n\tconnectInput( source ) {\r\n\t\tconst isHTML = source instanceof HTMLMediaElement;\r\n\r\n\t\tif ( ! ( isHTML || source.connect ) )\r\n\t\t\tthrow new AudioMotionError( ERR_INVALID_AUDIO_SOURCE );\r\n\r\n\t\t// if source is an HTML element, create an audio node for it; otherwise, use the provided audio node\r\n\t\tconst node = isHTML ? this.audioCtx.createMediaElementSource( source ) : source;\r\n\r\n\t\tif ( ! this._sources.includes( node ) ) {\r\n\t\t\tnode.connect( this._input );\r\n\t\t\tthis._sources.push( node );\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\t}\r\n\r\n\t/**\r\n\t * Connects the analyzer output to another audio node\r\n\t *\r\n\t * @param [{object}] an AudioNode; if undefined, the output is connected to the audio context destination (speakers)\r\n\t */\r\n\tconnectOutput( node = this.audioCtx.destination ) {\r\n\t\tif ( this._outNodes.includes( node ) )\r\n\t\t\treturn;\r\n\r\n\t\tthis._output.connect( node );\r\n\t\tthis._outNodes.push( node );\r\n\r\n\t\t// when connecting the first node, also connect the analyzer nodes to the merger / output nodes\r\n\t\tif ( this._outNodes.length == 1 ) {\r\n\t\t\tfor ( const i of [0,1] )\r\n\t\t\t\tthis._analyzer[ i ].connect( ( this._chLayout == CHANNEL_SINGLE && ! i ? this._output : this._merger ), 0, i );\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Destroys instance\r\n\t */\r\n\tdestroy() {\r\n\t\tif ( ! this._ready )\r\n\t\t\treturn;\r\n\r\n\t\tconst { audioCtx, canvas, _controller, _input, _merger, _observer, _ownCanvas, _ownContext, _splitter } = this;\r\n\r\n\t\tthis._destroyed = true;\r\n\t\tthis._ready = false;\r\n\t\tthis.stop();\r\n\r\n\t\t// remove event listeners\r\n\t\t_controller.abort();\r\n\t\tif ( _observer )\r\n\t\t\t_observer.disconnect();\r\n\r\n\t\t// clear callbacks and fullscreen element\r\n\t\tthis.onCanvasResize = null;\r\n\t\tthis.onCanvasDraw = null;\r\n\t\tthis._fsEl = null;\r\n\r\n\t\t// disconnect audio nodes\r\n\t\tthis.disconnectInput();\r\n\t\tthis.disconnectOutput(); // also disconnects analyzer nodes\r\n\t\t_input.disconnect();\r\n\t\t_splitter.disconnect();\r\n\t\t_merger.disconnect();\r\n\r\n\t\t// if audio context is our own (not provided by the user), close it\r\n\t\tif ( _ownContext )\r\n\t\t\taudioCtx.close();\r\n\r\n\t\t// remove canvas from the DOM (if not provided by the user)\r\n\t\tif ( _ownCanvas )\r\n\t\t\tcanvas.remove();\r\n\r\n\t\t// reset flags\r\n\t\tthis._calcBars();\r\n\t}\r\n\r\n\t/**\r\n\t * Disconnects audio sources from the analyzer\r\n\t *\r\n\t * @param [{object|array}] a connected AudioNode object or an array of such objects; if falsy, all connected nodes are disconnected\r\n\t * @param [{boolean}] if true, stops/releases audio tracks from disconnected media streams (e.g. microphone)\r\n\t */\r\n\tdisconnectInput( sources, stopTracks ) {\r\n\t\tif ( ! sources )\r\n\t\t\tsources = Array.from( this._sources );\r\n\t\telse if ( ! Array.isArray( sources ) )\r\n\t\t\tsources = [ sources ];\r\n\r\n\t\tfor ( const node of sources ) {\r\n\t\t\tconst idx = this._sources.indexOf( node );\r\n\t\t\tif ( stopTracks && node.mediaStream ) {\r\n\t\t\t\tfor ( const track of node.mediaStream.getAudioTracks() ) {\r\n\t\t\t\t\ttrack.stop();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ( idx >= 0 ) {\r\n\t\t\t\tnode.disconnect( this._input );\r\n\t\t\t\tthis._sources.splice( idx, 1 );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Disconnects the analyzer output from other audio nodes\r\n\t *\r\n\t * @param [{object}] a connected AudioNode object; if undefined, all connected nodes are disconnected\r\n\t */\r\n\tdisconnectOutput( node ) {\r\n\t\tif ( node && ! this._outNodes.includes( node ) )\r\n\t\t\treturn;\r\n\r\n\t\tthis._output.disconnect( node );\r\n\t\tthis._outNodes = node ? this._outNodes.filter( e => e !== node ) : [];\r\n\r\n\t\t// if disconnected from all nodes, also disconnect the analyzer nodes so they keep working on Chromium\r\n\t\t// see https://github.com/hvianna/audioMotion-analyzer/issues/13#issuecomment-808764848\r\n\t\tif ( this._outNodes.length == 0 ) {\r\n\t\t\tfor ( const i of [0,1] )\r\n\t\t\t\tthis._analyzer[ i ].disconnect();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns analyzer bars data\r\n     *\r\n\t * @returns {array}\r\n\t */\r\n\tgetBars() {\r\n\t\treturn Array.from( this._bars, ( { posX, freq, freqLo, freqHi, hold, peak, value } ) => ( { posX, freq, freqLo, freqHi, hold, peak, value } ) );\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the energy of a frequency, or average energy of a range of frequencies\r\n\t *\r\n\t * @param [{number|string}] single or initial frequency (Hz), or preset name; if undefined, returns the overall energy\r\n\t * @param [{number}] ending frequency (Hz)\r\n\t * @returns {number|null} energy value (0 to 1) or null, if the specified preset is unknown\r\n\t */\r\n\tgetEnergy( startFreq, endFreq ) {\r\n\t\tif ( startFreq === undefined )\r\n\t\t\treturn this._energy.val;\r\n\r\n\t\t// if startFreq is a string, check for presets\r\n\t\tif ( startFreq != +startFreq ) {\r\n\t\t\tif ( startFreq == 'peak' )\r\n\t\t\t\treturn this._energy.peak;\r\n\r\n\t\t\tconst presets = {\r\n\t\t\t\tbass:    [ 20, 250 ],\r\n\t\t\t\tlowMid:  [ 250, 500 ],\r\n\t\t\t\tmid:     [ 500, 2e3 ],\r\n\t\t\t\thighMid: [ 2e3, 4e3 ],\r\n\t\t\t\ttreble:  [ 4e3, 16e3 ]\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! presets[ startFreq ] )\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t[ startFreq, endFreq ] = presets[ startFreq ];\r\n\t\t}\r\n\r\n\t\tconst startBin = this._freqToBin( startFreq ),\r\n\t\t      endBin   = endFreq ? this._freqToBin( endFreq ) : startBin,\r\n\t\t      chnCount = this._chLayout == CHANNEL_SINGLE ? 1 : 2;\r\n\r\n\t\tlet energy = 0;\r\n\t\tfor ( let channel = 0; channel < chnCount; channel++ ) {\r\n\t\t\tfor ( let i = startBin; i <= endBin; i++ )\r\n\t\t\t\tenergy += this._normalizedB( this._fftData[ channel ][ i ] );\r\n\t\t}\r\n\r\n\t\treturn energy / ( endBin - startBin + 1 ) / chnCount;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns current analyzer settings in object format\r\n\t *\r\n\t * @param [{string|array}] a property name or an array of property names to not include in the returned object\r\n\t * @returns {object} Options object\r\n\t */\r\n\tgetOptions( ignore ) {\r\n\t\tif ( ! Array.isArray( ignore ) )\r\n\t\t\tignore = [ ignore ];\r\n\t\tlet options = {};\r\n\t\tfor ( const prop of Object.keys( DEFAULT_SETTINGS ) ) {\r\n\t\t\tif ( ! ignore.includes( prop ) ) {\r\n\t\t\t\tif ( prop == 'gradient' && this.gradientLeft != this.gradientRight ) {\r\n\t\t\t\t\toptions.gradientLeft = this.gradientLeft;\r\n\t\t\t\t\toptions.gradientRight = this.gradientRight;\r\n\t\t\t\t}\r\n\t\t\t\telse if ( prop != 'start' )\r\n\t\t\t\t\toptions[ prop ] = this[ prop ];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn options;\r\n\t}\r\n\r\n\t/**\r\n\t * Registers a custom gradient\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {object} options\r\n\t */\r\n\tregisterGradient( name, options ) {\r\n\t\tif ( typeof name != 'string' || name.trim().length == 0 )\r\n\t\t\tthrow new AudioMotionError( ERR_GRADIENT_INVALID_NAME );\r\n\r\n\t\tif ( typeof options != 'object' )\r\n\t\t\tthrow new AudioMotionError( ERR_GRADIENT_NOT_AN_OBJECT );\r\n\r\n\t\tconst { colorStops } = options;\r\n\r\n\t\tif ( ! Array.isArray( colorStops ) || ! colorStops.length )\r\n\t\t\tthrow new AudioMotionError( ERR_GRADIENT_MISSING_COLOR );\r\n\r\n\t\tconst count     = colorStops.length,\r\n\t\t\t  isInvalid = val => +val != val || val < 0 || val > 1;\r\n\r\n\t\t// normalize all colorStops as objects with `pos`, `color` and `level` properties\r\n\t\tcolorStops.forEach( ( colorStop, index ) => {\r\n\t\t\tconst pos = index / Math.max( 1, count - 1 );\r\n\t\t\tif ( typeof colorStop != 'object' ) // only color string was defined\r\n\t\t\t\tcolorStops[ index ] = {\tpos, color: colorStop };\r\n\t\t\telse if ( isInvalid( colorStop.pos ) )\r\n\t\t\t\tcolorStop.pos = pos;\r\n\r\n\t\t\tif ( isInvalid( colorStop.level ) )\r\n\t\t\t\tcolorStops[ index ].level = 1 - index / count;\r\n\t\t});\r\n\r\n\t\t// make sure colorStops is in descending `level` order and that the first one has `level == 1`\r\n\t\t// this is crucial for proper operation of 'bar-level' colorMode!\r\n\t\tcolorStops.sort( ( a, b ) => a.level < b.level ? 1 : a.level > b.level ? -1 : 0 );\r\n\t\tcolorStops[0].level = 1;\r\n\r\n\t\tthis._gradients[ name ] = {\r\n\t\t\tbgColor:    options.bgColor || GRADIENT_DEFAULT_BGCOLOR,\r\n\t\t\tdir:        options.dir,\r\n\t\t\tcolorStops: colorStops\r\n\t\t};\r\n\r\n\t\t// if the registered gradient is one of the currently selected gradients, regenerate them\r\n\t\tif ( this._selectedGrads.includes( name ) )\r\n\t\t\tthis._makeGrad();\r\n\t}\r\n\r\n\t/**\r\n\t * Set dimensions of analyzer's canvas\r\n\t *\r\n\t * @param {number} w width in pixels\r\n\t * @param {number} h height in pixels\r\n\t */\r\n\tsetCanvasSize( w, h ) {\r\n\t\tthis._width = w;\r\n\t\tthis._height = h;\r\n\t\tthis._setCanvas( REASON_USER );\r\n\t}\r\n\r\n\t/**\r\n\t * Set desired frequency range\r\n\t *\r\n\t * @param {number} min lowest frequency represented in the x-axis\r\n\t * @param {number} max highest frequency represented in the x-axis\r\n\t */\r\n\tsetFreqRange( min, max ) {\r\n\t\tif ( min < 1 || max < 1 )\r\n\t\t\tthrow new AudioMotionError( ERR_FREQUENCY_TOO_LOW );\r\n\t\telse {\r\n\t\t\tthis._minFreq = Math.min( min, max );\r\n\t\t\tthis.maxFreq  = Math.max( min, max ); // use the setter for maxFreq\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Set custom parameters for LED effect\r\n\t * If called with no arguments or if any property is invalid, clears any previous custom parameters\r\n\t *\r\n\t * @param {object} [params]\r\n\t */\r\n\tsetLedParams( params ) {\r\n\t\tlet maxLeds, spaceV, spaceH;\r\n\r\n\t\t// coerce parameters to Number; `NaN` results are rejected in the condition below\r\n\t\tif ( params ) {\r\n\t\t\tmaxLeds = params.maxLeds | 0, // ensure integer\r\n\t\t\tspaceV  = +params.spaceV,\r\n\t\t\tspaceH  = +params.spaceH;\r\n\t\t}\r\n\r\n\t\tthis._ledParams = maxLeds > 0 && spaceV > 0 && spaceH >= 0 ? [ maxLeds, spaceV, spaceH ] : undefined;\r\n\t\tthis._calcBars();\r\n\t}\r\n\r\n\t/**\r\n\t * Shorthand function for setting several options at once\r\n\t *\r\n\t * @param {object} options\r\n\t */\r\n\tsetOptions( options ) {\r\n\t\tthis._setProps( options );\r\n\t}\r\n\r\n\t/**\r\n\t * Adjust the analyzer's sensitivity\r\n\t *\r\n\t * @param {number} min minimum decibels value\r\n\t * @param {number} max maximum decibels value\r\n\t */\r\n\tsetSensitivity( min, max ) {\r\n\t\tfor ( const i of [0,1] ) {\r\n\t\t\tthis._analyzer[ i ].minDecibels = Math.min( min, max );\r\n\t\t\tthis._analyzer[ i ].maxDecibels = Math.max( min, max );\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Start the analyzer\r\n\t */\r\n\tstart() {\r\n\t\tthis.toggleAnalyzer( true );\r\n\t}\r\n\r\n\t/**\r\n\t * Stop the analyzer\r\n\t */\r\n\tstop() {\r\n\t\tthis.toggleAnalyzer( false );\r\n\t}\r\n\r\n\t/**\r\n\t * Start / stop canvas animation\r\n\t *\r\n\t * @param {boolean} [force] if undefined, inverts the current state\r\n\t * @returns {boolean} resulting state after the change\r\n\t */\r\n\ttoggleAnalyzer( force ) {\r\n\t\tconst hasStarted = this.isOn;\r\n\r\n\t\tif ( force === undefined )\r\n\t\t\tforce = ! hasStarted;\r\n\r\n\t\t// Stop the analyzer if it was already running and must be disabled\r\n\t\tif ( hasStarted && ! force ) {\r\n\t\t\tcancelAnimationFrame( this._runId );\r\n\t\t\tthis._runId = 0;\r\n\t\t}\r\n\t\t// Start the analyzer if it was stopped and must be enabled\r\n\t\telse if ( ! hasStarted && force && ! this._destroyed ) {\r\n\t\t\tthis._frames = 0;\r\n\t\t\tthis._time = performance.now();\r\n\t\t\tthis._runId = requestAnimationFrame( timestamp => this._draw( timestamp ) ); // arrow function preserves the scope of *this*\r\n\t\t}\r\n\r\n\t\treturn this.isOn;\r\n\t}\r\n\r\n\t/**\r\n\t * Toggles canvas full-screen mode\r\n\t */\r\n\ttoggleFullscreen() {\r\n\t\tif ( this.isFullscreen ) {\r\n\t\t\tif ( document.exitFullscreen )\r\n\t\t\t\tdocument.exitFullscreen();\r\n\t\t\telse if ( document.webkitExitFullscreen )\r\n\t\t\t\tdocument.webkitExitFullscreen();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tconst fsEl = this._fsEl;\r\n\t\t\tif ( ! fsEl )\r\n\t\t\t\treturn;\r\n\t\t\tif ( fsEl.requestFullscreen )\r\n\t\t\t\tfsEl.requestFullscreen();\r\n\t\t\telse if ( fsEl.webkitRequestFullscreen )\r\n\t\t\t\tfsEl.webkitRequestFullscreen();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t *\r\n\t * PRIVATE METHODS\r\n\t *\r\n\t * ==========================================================================\r\n\t */\r\n\r\n\t/**\r\n\t * Return the frequency (in Hz) for a given FFT bin\r\n\t */\r\n\t_binToFreq( bin ) {\r\n\t\treturn bin * this.audioCtx.sampleRate / this.fftSize || 1; // returns 1 for bin 0\r\n\t}\r\n\r\n\t/**\r\n\t * Compute all internal data required for the analyzer, based on its current settings\r\n\t */\r\n\t_calcBars() {\r\n\t\tconst bars = this._bars = []; // initialize object property\r\n\r\n\t\tif ( ! this._ready ) {\r\n\t\t\tthis._flg = { isAlpha: false, isBands: false, isLeds: false, isLumi: false, isOctaves: false, isOutline: false, isRound: false, noLedGap: false };\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst { _ansiBands, _barSpace, canvas, _chLayout, _maxFreq, _minFreq, _mirror, _mode, _radial, _radialInvert, _reflexRatio } = this,\r\n\t\t\t  centerX          = canvas.width >> 1,\r\n\t\t\t  centerY          = canvas.height >> 1,\r\n\t\t\t  isDualVertical   = _chLayout == CHANNEL_VERTICAL && ! _radial,\r\n\t\t\t  isDualHorizontal = _chLayout == CHANNEL_HORIZONTAL,\r\n\r\n\t\t\t  // COMPUTE FLAGS\r\n\r\n\t\t\t  isBands   = _mode % 10 != 0, // true for modes 1 to 9\r\n\t\t\t  isOctaves = isBands && this._frequencyScale == SCALE_LOG,\r\n\t\t\t  isLeds    = this._showLeds && isBands && ! _radial,\r\n\t\t\t  isLumi    = this._lumiBars && isBands && ! _radial,\r\n\t\t\t  isAlpha   = this._alphaBars && ! isLumi && _mode != MODE_GRAPH,\r\n\t\t\t  isOutline = this._outlineBars && isBands && ! isLumi && ! isLeds,\r\n\t\t\t  isRound   = this._roundBars && isBands && ! isLumi && ! isLeds,\r\n\t\t\t  noLedGap  = _chLayout != CHANNEL_VERTICAL || _reflexRatio > 0 && ! isLumi,\r\n\r\n\t\t\t  // COMPUTE AUXILIARY VALUES\r\n\r\n\t\t\t  // channelHeight is the total canvas height dedicated to each channel, including the reflex area, if any)\r\n\t\t\t  channelHeight  = canvas.height - ( isDualVertical && ! isLeds ? .5 : 0 ) >> isDualVertical,\r\n\t\t\t  // analyzerHeight is the effective height used to render the analyzer, excluding the reflex area\r\n\t\t\t  analyzerHeight = channelHeight * ( isLumi || _radial ? 1 : 1 - _reflexRatio ) | 0,\r\n\r\n\t\t\t  analyzerWidth  = canvas.width - centerX * ( isDualHorizontal || _mirror != 0 ),\r\n\r\n\t\t\t  // channelGap is **0** if isLedDisplay == true (LEDs already have spacing); **1** if canvas height is odd (windowed); **2** if it's even\r\n\t\t\t  // TODO: improve this, make it configurable?\r\n\t\t\t  channelGap     = isDualVertical ? canvas.height - channelHeight * 2 : 0,\r\n\r\n\t\t\t  initialX       = centerX * ( _mirror == -1 && ! isDualHorizontal && ! _radial );\r\n\r\n\t\tlet innerRadius = Math.min( canvas.width, canvas.height ) * .375 * ( _chLayout == CHANNEL_VERTICAL ? 1 : this._radius ) | 0,\r\n\t\t\touterRadius = Math.min( centerX, centerY );\r\n\r\n\t\tif ( _radialInvert && _chLayout != CHANNEL_VERTICAL )\r\n\t\t\t[ innerRadius, outerRadius ] = [ outerRadius, innerRadius ];\r\n\r\n\t\t/**\r\n\t\t *\tCREATE ANALYZER BANDS\r\n\t\t *\r\n\t\t *\tUSES:\r\n\t\t *\t\tanalyzerWidth\r\n\t\t *\t\tinitialX\r\n\t\t *\t\tisBands\r\n\t\t *\t\tisOctaves\r\n\t\t *\r\n\t\t *\tGENERATES:\r\n\t\t *\t\tbars (populates this._bars)\r\n\t\t *\t\tbardWidth\r\n\t\t *\t\tscaleMin\r\n\t\t *\t\tunitWidth\r\n\t\t */\r\n\r\n\t\t// helper function to add a bar to the bars array\r\n\t\t// bar object format:\r\n\t\t// {\r\n\t\t//\t posX,\r\n\t\t//   freq,\r\n\t\t//   freqLo,\r\n\t\t//   freqHi,\r\n\t\t//   binLo,\r\n\t\t//   binHi,\r\n\t\t//   ratioLo,\r\n\t\t//   ratioHi,\r\n\t\t//   peak,    // peak value\r\n\t\t//   hold,    // peak hold frames (negative value indicates peak falling / fading)\r\n\t\t//   alpha,   // peak alpha (used by fadePeaks)\r\n\t\t//   value    // current bar value\r\n\t\t// }\r\n\t\tconst barsPush = args => bars.push( { ...args, peak: [0,0], hold: [0], alpha: [0], value: [0] } );\r\n\r\n\t\t/*\r\n\t\t\tA simple interpolation is used to obtain an approximate amplitude value for any given frequency,\r\n\t\t\tfrom the available FFT data. We find the FFT bin which closer matches the desired frequency\tand\r\n\t\t\tinterpolate its value with that of the next adjacent bin, like so:\r\n\r\n\t\t\t\tv = v0 + ( v1 - v0 ) * ( log2( f / f0 ) / log2( f1 / f0 ) )\r\n\t\t\t\t                       \\__________________________________/\r\n\t\t\t\t                                        |\r\n\t\t\t\t                                      ratio\r\n\t\t\t\twhere:\r\n\r\n\t\t\t\tf  - desired frequency\r\n\t\t\t\tv  - amplitude (volume) of desired frequency\r\n\t\t\t\tf0 - frequency represented by the lower FFT bin\r\n\t\t\t\tf1 - frequency represented by the upper FFT bin\r\n\t\t\t\tv0 - amplitude of f0\r\n\t\t\t\tv1 - amplitude of f1\r\n\r\n\t\t\tratio is calculated in advance here, to reduce computational complexity during real-time rendering.\r\n\t\t*/\r\n\r\n\t\t// helper function to calculate FFT bin and interpolation ratio for a given frequency\r\n\t\tconst calcRatio = freq => {\r\n\t\t\tconst bin   = this._freqToBin( freq, 'floor' ), // find closest FFT bin\r\n\t\t\t\t  lower = this._binToFreq( bin ),\r\n\t\t\t\t  upper = this._binToFreq( bin + 1 ),\r\n\t\t\t\t  ratio = Math.log2( freq / lower ) / Math.log2( upper / lower );\r\n\r\n\t\t\treturn [ bin, ratio ];\r\n\t\t}\r\n\r\n\t\tlet barWidth, scaleMin, unitWidth;\r\n\r\n\t\tif ( isOctaves ) {\r\n\t\t\t// helper function to round a value to a given number of significant digits\r\n\t\t\t// `atLeast` set to true prevents reducing the number of integer significant digits\r\n\t\t\tconst roundSD = ( value, digits, atLeast ) => +value.toPrecision( atLeast ? Math.max( digits, 1 + Math.log10( value ) | 0 ) : digits );\r\n\r\n\t\t\t// helper function to find the nearest preferred number (Renard series) for a given value\r\n\t\t\tconst nearestPreferred = value => {\r\n\t\t\t\t// R20 series is used here, as it provides closer approximations for 1/2 octave bands (non-standard)\r\n\t\t\t\tconst preferred = [ 1, 1.12, 1.25, 1.4, 1.6, 1.8, 2, 2.24, 2.5, 2.8, 3.15, 3.55, 4, 4.5, 5, 5.6, 6.3, 7.1, 8, 9, 10 ],\r\n\t\t\t\t\t  power = Math.log10( value ) | 0,\r\n\t\t\t\t\t  normalized = value / 10 ** power;\r\n\r\n\t\t\t\tlet i = 1;\r\n\t\t\t\twhile ( i < preferred.length && normalized > preferred[ i ] )\r\n\t\t\t\t\ti++;\r\n\r\n\t\t\t\tif ( normalized - preferred[ i - 1 ] < preferred[ i ] - normalized )\r\n\t\t\t\t\ti--;\r\n\r\n\t\t\t\treturn ( preferred[ i ] * 10 ** ( power + 5 ) | 0 ) / 1e5; // keep 5 significant digits\r\n\t\t\t}\r\n\r\n\t\t\t// ANSI standard octave bands use the base-10 frequency ratio, as preferred by [ANSI S1.11-2004, p.2]\r\n\t\t\t// The equal-tempered scale uses the base-2 ratio\r\n\t\t\tconst bands = [0,24,12,8,6,4,3,2,1][ _mode ],\r\n\t\t\t\t  bandWidth = _ansiBands ? 10 ** ( 3 / ( bands * 10 ) ) : 2 ** ( 1 / bands ), // 10^(3/10N) or 2^(1/N)\r\n\t\t\t\t  halfBand  = bandWidth ** .5;\r\n\r\n\t\t\tlet analyzerBars = [],\r\n\t\t\t\tcurrFreq = _ansiBands ? 7.94328235 / ( bands % 2 ? 1 : halfBand ) : C_1;\r\n\t\t\t\t// For ANSI bands with even denominators (all except 1/1 and 1/3), the reference frequency (1 kHz)\r\n\t\t\t\t// must fall on the edges of a pair of adjacent bands, instead of midband [ANSI S1.11-2004, p.2]\r\n\t\t\t\t// In the equal-tempered scale, all midband frequencies represent a musical note or quarter-tone.\r\n\r\n\t\t\tdo {\r\n\t\t\t\tlet freq = currFreq; // midband frequency\r\n\r\n\t\t\t\tconst freqLo = roundSD( freq / halfBand, 4, true ), // lower edge frequency\r\n\t\t\t\t\t  freqHi = roundSD( freq * halfBand, 4, true ), // upper edge frequency\r\n\t\t\t\t\t  [ binLo, ratioLo ] = calcRatio( freqLo ),\r\n\t\t\t\t\t  [ binHi, ratioHi ] = calcRatio( freqHi );\r\n\r\n\t\t\t\t// for 1/1, 1/2 and 1/3 ANSI bands, use the preferred numbers to find the nominal midband frequency\r\n\t\t\t\t// for 1/4 to 1/24, round to 2 or 3 significant digits, according to the MSD [ANSI S1.11-2004, p.12]\r\n\t\t\t\tif ( _ansiBands )\r\n\t\t\t\t\tfreq = bands < 4 ? nearestPreferred( freq ) : roundSD( freq, freq.toString()[0] < 5 ? 3 : 2 );\r\n\t\t\t\telse\r\n\t\t\t\t\tfreq = roundSD( freq, 4, true );\r\n\r\n\t\t\t\tif ( freq >= _minFreq )\r\n\t\t\t\t\tbarsPush( { posX: 0, freq, freqLo, freqHi, binLo, binHi, ratioLo, ratioHi } );\r\n\r\n\t\t\t\tcurrFreq *= bandWidth;\r\n\t\t\t} while ( currFreq <= _maxFreq );\r\n\r\n\t\t\tbarWidth = analyzerWidth / bars.length;\r\n\r\n\t\t\tbars.forEach( ( bar, index ) => bar.posX = initialX + index * barWidth );\r\n\r\n\t\t\tconst firstBar = bars[0],\r\n\t\t\t\t  lastBar  = bars[ bars.length - 1 ];\r\n\r\n\t\t\tscaleMin = this._freqScaling( firstBar.freqLo );\r\n\t\t\tunitWidth = analyzerWidth / ( this._freqScaling( lastBar.freqHi ) - scaleMin );\r\n\r\n\t\t\t// clamp edge frequencies to minFreq / maxFreq, if necessary\r\n\t\t\t// this is done after computing scaleMin and unitWidth, for the proper positioning of labels on the X-axis\r\n\t\t\tif ( firstBar.freqLo < _minFreq ) {\r\n\t\t\t\tfirstBar.freqLo = _minFreq;\r\n\t\t\t\t[ firstBar.binLo, firstBar.ratioLo ] = calcRatio( _minFreq );\r\n\t\t\t}\r\n\r\n\t\t\tif ( lastBar.freqHi > _maxFreq ) {\r\n\t\t\t\tlastBar.freqHi = _maxFreq;\r\n\t\t\t\t[ lastBar.binHi, lastBar.ratioHi ] = calcRatio( _maxFreq );\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if ( isBands ) { // a bands mode is selected, but frequency scale is not logarithmic\r\n\r\n\t\t\tconst bands = [0,24,12,8,6,4,3,2,1][ _mode ] * 10;\r\n\r\n\t\t\tconst invFreqScaling = x => {\r\n\t\t\t\tswitch ( this._frequencyScale ) {\r\n\t\t\t\t\tcase SCALE_BARK :\r\n\t\t\t\t\t\treturn 1960 / ( 26.81 / ( x + .53 ) - 1 );\r\n\t\t\t\t\tcase SCALE_MEL :\r\n\t\t\t\t\t\treturn 700 * ( 2 ** x - 1 );\r\n\t\t\t\t\tcase SCALE_LINEAR :\r\n\t\t\t\t\t\treturn x;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbarWidth = analyzerWidth / bands;\r\n\r\n\t\t\tscaleMin = this._freqScaling( _minFreq );\r\n\t\t\tunitWidth = analyzerWidth / ( this._freqScaling( _maxFreq ) - scaleMin );\r\n\r\n\t\t\tfor ( let i = 0, posX = 0; i < bands; i++, posX += barWidth ) {\r\n\t\t\t\tconst freqLo = invFreqScaling( scaleMin + posX / unitWidth ),\r\n\t\t\t\t\t  freq   = invFreqScaling( scaleMin + ( posX + barWidth / 2 ) / unitWidth ),\r\n\t\t\t\t\t  freqHi = invFreqScaling( scaleMin + ( posX + barWidth ) / unitWidth ),\r\n\t\t\t\t\t  [ binLo, ratioLo ] = calcRatio( freqLo ),\r\n\t\t\t\t\t  [ binHi, ratioHi ] = calcRatio( freqHi );\r\n\r\n\t\t\t\tbarsPush( { posX: initialX + posX, freq, freqLo, freqHi, binLo, binHi, ratioLo, ratioHi } );\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\telse {\t// Discrete frequencies modes\r\n\t\t\tbarWidth = 1;\r\n\r\n\t\t\tscaleMin = this._freqScaling( _minFreq );\r\n\t\t\tunitWidth = analyzerWidth / ( this._freqScaling( _maxFreq ) - scaleMin );\r\n\r\n\t\t\tconst minIndex = this._freqToBin( _minFreq, 'floor' ),\r\n\t\t\t\t  maxIndex = this._freqToBin( _maxFreq );\r\n\r\n\t \t\tlet lastPos = -999;\r\n\r\n\t\t\tfor ( let i = minIndex; i <= maxIndex; i++ ) {\r\n\t\t\t\tconst freq = this._binToFreq( i ), // frequency represented by this index\r\n\t\t\t\t\t  posX = initialX + Math.round( unitWidth * ( this._freqScaling( freq ) - scaleMin ) ); // avoid fractionary pixel values\r\n\r\n\t\t\t\t// if it's on a different X-coordinate, create a new bar for this frequency\r\n\t\t\t\tif ( posX > lastPos ) {\r\n\t\t\t\t\tbarsPush( { posX, freq, freqLo: freq, freqHi: freq, binLo: i, binHi: i, ratioLo: 0, ratioHi: 0 } );\r\n\t\t\t\t\tlastPos = posX;\r\n\t\t\t\t} // otherwise, add this frequency to the last bar's range\r\n\t\t\t\telse if ( bars.length ) {\r\n\t\t\t\t\tconst lastBar = bars[ bars.length - 1 ];\r\n\t\t\t\t\tlastBar.binHi = i;\r\n\t\t\t\t\tlastBar.freqHi = freq;\r\n\t\t\t\t\tlastBar.freq = ( lastBar.freqLo * freq ) ** .5; // compute center frequency (geometric mean)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t *  COMPUTE ATTRIBUTES FOR THE LED BARS\r\n\t\t *\r\n\t\t *\tUSES:\r\n\t\t *\t\tanalyzerHeight\r\n\t\t *\t\tbarWidth\r\n\t\t *\t\tnoLedGap\r\n\t\t *\r\n\t\t *\tGENERATES:\r\n\t\t * \t\tspaceH\r\n\t\t * \t\tspaceV\r\n\t\t *\t\tthis._leds\r\n\t\t */\r\n\r\n\t\tlet spaceH = 0,\r\n\t\t\tspaceV = 0;\r\n\r\n\t\tif ( isLeds ) {\r\n\t\t\t// adjustment for high pixel-ratio values on low-resolution screens (Android TV)\r\n\t\t\tconst dPR = this._pixelRatio / ( window.devicePixelRatio > 1 && window.screen.height <= 540 ? 2 : 1 );\r\n\r\n\t\t\tconst params = [ [],\r\n\t\t\t\t[ 128,  3, .45  ], // mode 1\r\n\t\t\t\t[ 128,  4, .225 ], // mode 2\r\n\t\t\t\t[  96,  6, .225 ], // mode 3\r\n\t\t\t\t[  80,  6, .225 ], // mode 4\r\n\t\t\t\t[  80,  6, .125 ], // mode 5\r\n\t\t\t\t[  64,  6, .125 ], // mode 6\r\n\t\t\t\t[  48,  8, .125 ], // mode 7\r\n\t\t\t\t[  24, 16, .125 ], // mode 8\r\n\t\t\t];\r\n\r\n\t\t\t// use custom LED parameters if set, or the default parameters for the current mode\r\n\t\t\tconst customParams = this._ledParams,\r\n\t\t\t\t  [ maxLeds, spaceVRatio, spaceHRatio ] = customParams || params[ _mode ];\r\n\r\n\t\t\tlet ledCount, maxHeight = analyzerHeight;\r\n\r\n\t\t\tif ( customParams ) {\r\n\t\t\t\tconst minHeight = 2 * dPR;\r\n\t\t\t\tlet blockHeight;\r\n\t\t\t\tledCount = maxLeds + 1;\r\n\t\t\t\tdo {\r\n\t\t\t\t\tledCount--;\r\n\t\t\t\t\tblockHeight = maxHeight / ledCount / ( 1 + spaceVRatio );\r\n\t\t\t\t\tspaceV = blockHeight * spaceVRatio;\r\n\t\t\t\t} while ( ( blockHeight < minHeight || spaceV < minHeight ) && ledCount > 1 );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// calculate vertical spacing - aim for the reference ratio, but make sure it's at least 2px\r\n\t\t\t\tconst refRatio = 540 / spaceVRatio;\r\n\t\t\t\tspaceV = Math.min( spaceVRatio * dPR, Math.max( 2, maxHeight / refRatio + .1 | 0 ) );\r\n\t\t\t}\r\n\r\n\t\t\t// remove the extra spacing below the last line of LEDs\r\n\t\t\tif ( noLedGap )\r\n\t\t\t\tmaxHeight += spaceV;\r\n\r\n\t\t\t// recalculate the number of leds, considering the effective spaceV\r\n\t\t\tif ( ! customParams )\r\n\t\t\t\tledCount = Math.min( maxLeds, maxHeight / ( spaceV * 2 ) | 0 );\r\n\r\n\t\t\tspaceH = spaceHRatio >= 1 ? spaceHRatio : barWidth * spaceHRatio;\r\n\r\n\t\t\tthis._leds = [\r\n\t\t\t\tledCount,\r\n\t\t\t\tspaceH,\r\n\t\t\t\tspaceV,\r\n\t\t\t\tmaxHeight / ledCount - spaceV // ledHeight\r\n\t\t\t];\r\n\t\t}\r\n\r\n\t\t// COMPUTE ADDITIONAL BAR POSITIONING, ACCORDING TO THE CURRENT SETTINGS\r\n\t\t// uses: _barSpace, barWidth, spaceH\r\n\r\n\t\tconst barSpacePx = Math.min( barWidth - 1, _barSpace * ( _barSpace > 0 && _barSpace < 1 ? barWidth : 1 ) );\r\n\r\n\t\tif ( isBands )\r\n\t\t\tbarWidth -= Math.max( isLeds ? spaceH : 0, barSpacePx );\r\n\r\n\t\tbars.forEach( ( bar, index ) => {\r\n\t\t\tlet posX  = bar.posX,\r\n\t\t\t\twidth = barWidth;\r\n\r\n\t\t\t// in bands modes we need to update bar.posX to account for bar/led spacing\r\n\r\n\t\t\tif ( isBands ) {\r\n\t\t\t\tif ( _barSpace == 0 && ! isLeds ) {\r\n\t\t\t\t\t// when barSpace == 0 use integer values for perfect gapless positioning\r\n\t\t\t\t\tposX |= 0;\r\n\t\t\t\t\twidth |= 0;\r\n\t\t\t\t\tif ( index > 0 && posX > bars[ index - 1 ].posX + bars[ index - 1 ].width ) {\r\n\t\t\t\t\t\tposX--;\r\n\t\t\t\t\t\twidth++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tposX += Math.max( ( isLeds ? spaceH : 0 ), barSpacePx ) / 2;\r\n\r\n\t\t\t\tbar.posX = posX; // update\r\n\t\t\t}\r\n\r\n\t\t\tbar.barCenter = posX + ( barWidth == 1 ? 0 : width / 2 );\r\n\t\t\tbar.width = width;\r\n\t\t});\r\n\r\n\t\t// COMPUTE CHANNEL COORDINATES (uses spaceV)\r\n\r\n\t\tconst channelCoords = [];\r\n\t\tfor ( const channel of [0,1] ) {\r\n\t\t\tconst channelTop     = _chLayout == CHANNEL_VERTICAL ? ( channelHeight + channelGap ) * channel : 0,\r\n\t\t\t\t  channelBottom  = channelTop + channelHeight,\r\n\t\t\t\t  analyzerBottom = channelTop + analyzerHeight - ( ! isLeds || noLedGap ? 0 : spaceV );\r\n\r\n\t\t\tchannelCoords.push( { channelTop, channelBottom, analyzerBottom } );\r\n\t\t}\r\n\r\n\t\t// SAVE INTERNAL PROPERTIES\r\n\r\n\t\tthis._aux = { analyzerHeight, analyzerWidth, centerX, centerY, channelCoords, channelHeight, channelGap, initialX, innerRadius, outerRadius, scaleMin, unitWidth };\r\n\t\tthis._flg = { isAlpha, isBands, isLeds, isLumi, isOctaves, isOutline, isRound, noLedGap };\r\n\r\n\t\t// generate the X-axis and radial scales\r\n\t\tthis._createScales();\r\n\t}\r\n\r\n\t/**\r\n\t * Generate the X-axis and radial scales in auxiliary canvases\r\n\t */\r\n\t_createScales() {\r\n\t\tif ( ! this._ready )\r\n\t\t\treturn;\r\n\r\n\t\tconst { analyzerWidth, initialX, innerRadius, scaleMin, unitWidth } = this._aux,\r\n\t\t\t  { canvas, _frequencyScale, _mirror, _noteLabels, _radial, _scaleX, _scaleR } = this,\r\n\t\t\t  canvasX          = _scaleX.canvas,\r\n\t\t\t  canvasR          = _scaleR.canvas,\r\n\t\t\t  freqLabels       = [],\r\n\t\t\t  isDualHorizontal = this._chLayout == CHANNEL_HORIZONTAL,\r\n\t\t\t  isDualVertical   = this._chLayout == CHANNEL_VERTICAL,\r\n\t\t\t  minDimension     = Math.min( canvas.width, canvas.height ),\r\n\t\t\t  scale            = [ 'C',, 'D',, 'E', 'F',, 'G',, 'A',, 'B' ], // for note labels (no sharp notes)\r\n\t\t\t  scaleHeight      = minDimension / 34 | 0, // circular scale height (radial mode)\r\n  \t\t\t  fontSizeX        = canvasX.height >> 1,\r\n\t\t\t  fontSizeR        = scaleHeight >> 1,\r\n\t\t\t  labelWidthX      = fontSizeX * ( _noteLabels ? .7 : 1.5 ),\r\n\t\t\t  labelWidthR      = fontSizeR * ( _noteLabels ? 1 : 2 ),\r\n\t\t  \t  root12           = 2 ** ( 1 / 12 );\r\n\r\n\t\tif ( ! _noteLabels && ( this._ansiBands || _frequencyScale != SCALE_LOG ) ) {\r\n\t\t\tfreqLabels.push( 16, 31.5, 63, 125, 250, 500, 1e3, 2e3, 4e3 );\r\n\t\t\tif ( _frequencyScale == SCALE_LINEAR )\r\n\t\t\t\tfreqLabels.push( 6e3, 8e3, 10e3, 12e3, 14e3, 16e3, 18e3, 20e3, 22e3 );\r\n\t\t\telse\r\n\t\t\t\tfreqLabels.push( 8e3, 16e3 );\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet freq = C_1;\r\n\t\t\tfor ( let octave = -1; octave < 11; octave++ ) {\r\n\t\t\t\tfor ( let note = 0; note < 12; note++ ) {\r\n\t\t\t\t\tif ( freq >= this._minFreq && freq <= this._maxFreq ) {\r\n\t\t\t\t\t\tconst pitch = scale[ note ],\r\n\t\t\t\t\t\t\t  isC   = pitch == 'C';\r\n\t\t\t\t\t\tif ( ( pitch && _noteLabels && ! _mirror && ! isDualHorizontal ) || isC )\r\n\t\t\t\t\t\t\tfreqLabels.push( _noteLabels ? [ freq, pitch + ( isC ? octave : '' ) ] : freq );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfreq *= root12;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// in radial dual-vertical layout, the scale is positioned exactly between both channels, by making the canvas a bit larger than the inner diameter\r\n\t\tcanvasR.width = canvasR.height = Math.max( minDimension * .15, ( innerRadius << 1 ) + ( isDualVertical * scaleHeight ) );\r\n\r\n\t\tconst centerR = canvasR.width >> 1,\r\n\t\t\t  radialY = centerR - scaleHeight * .7;\t// vertical position of text labels in the circular scale\r\n\r\n\t\t// helper function\r\n\t\tconst radialLabel = ( x, label ) => {\r\n\t\t\tconst angle  = TAU * ( x / canvas.width ),\r\n\t\t\t\t  adjAng = angle - HALF_PI, // rotate angles so 0 is at the top\r\n\t\t\t\t  posX   = radialY * Math.cos( adjAng ),\r\n\t\t\t\t  posY   = radialY * Math.sin( adjAng );\r\n\r\n\t\t\t_scaleR.save();\r\n\t\t\t_scaleR.translate( centerR + posX, centerR + posY );\r\n\t\t\t_scaleR.rotate( angle );\r\n\t\t\t_scaleR.fillText( label, 0, 0 );\r\n\t\t\t_scaleR.restore();\r\n\t\t}\r\n\r\n\t\t// clear scale canvas\r\n\t\tcanvasX.width |= 0;\r\n\r\n\t\t_scaleX.fillStyle = _scaleR.strokeStyle = SCALEX_BACKGROUND_COLOR;\r\n\t\t_scaleX.fillRect( 0, 0, canvasX.width, canvasX.height );\r\n\r\n\t\t_scaleR.arc( centerR, centerR, centerR - scaleHeight / 2, 0, TAU );\r\n\t\t_scaleR.lineWidth = scaleHeight;\r\n\t\t_scaleR.stroke();\r\n\r\n\t\t_scaleX.fillStyle = _scaleR.fillStyle = SCALEX_LABEL_COLOR;\r\n\t\t_scaleX.font = `${ fontSizeX }px ${FONT_FAMILY}`;\r\n\t\t_scaleR.font = `${ fontSizeR }px ${FONT_FAMILY}`;\r\n\t\t_scaleX.textAlign = _scaleR.textAlign = 'center';\r\n\r\n\t\tlet prevX = -labelWidthX / 4,\r\n\t\t\tprevR = -labelWidthR;\r\n\r\n\t\tfor ( const item of freqLabels ) {\r\n\t\t\tconst [ freq, label ] = Array.isArray( item ) ? item : [ item, item < 1e3 ? item | 0 : `${ ( item / 100 | 0 ) / 10 }k` ],\r\n\t\t\t\t  x    = unitWidth * ( this._freqScaling( freq ) - scaleMin ),\r\n\t\t\t\t  y    = canvasX.height * .75,\r\n\t\t\t\t  isC  = label[0] == 'C',\r\n\t  \t\t\t  maxW = fontSizeX * ( _noteLabels && ! _mirror && ! isDualHorizontal ? ( isC ? 1.2 : .6 ) : 3 );\r\n\r\n\t  \t\t// set label color - no highlight when mirror effect is active (only Cs displayed)\r\n\t\t\t_scaleX.fillStyle = _scaleR.fillStyle = isC && ! _mirror && ! isDualHorizontal ? SCALEX_HIGHLIGHT_COLOR : SCALEX_LABEL_COLOR;\r\n\r\n\t\t\t// prioritizes which note labels are displayed, due to the restricted space on some ranges/scales\r\n\t\t\tif ( _noteLabels ) {\r\n\t\t\t\tconst isLog = _frequencyScale == SCALE_LOG,\r\n\t\t\t\t\t  isLinear = _frequencyScale == SCALE_LINEAR;\r\n\r\n\t\t\t\tlet allowedLabels = ['C'];\r\n\r\n\t\t\t\tif ( isLog || freq > 2e3 || ( ! isLinear && freq > 250 ) ||\r\n\t\t\t\t\t ( ( ! _radial || isDualVertical ) && ( ! isLinear && freq > 125 || freq > 1e3 ) ) )\r\n\t\t\t\t\tallowedLabels.push('G');\r\n\t\t\t\tif ( isLog || freq > 4e3 || ( ! isLinear && freq > 500 ) ||\r\n\t\t\t\t\t ( ( ! _radial || isDualVertical ) && ( ! isLinear && freq > 250 || freq > 2e3 ) ) )\r\n\t\t\t\t\tallowedLabels.push('E');\r\n\t\t\t\tif ( isLinear && freq > 4e3 ||\r\n\t\t\t\t\t ( ( ! _radial || isDualVertical ) && ( isLog || freq > 2e3 || ( ! isLinear && freq > 500 ) ) ) )\r\n\t\t\t\t\tallowedLabels.push('D','F','A','B');\r\n\t\t\t\tif ( ! allowedLabels.includes( label[0] ) )\r\n\t\t\t\t\tcontinue; // skip this label\r\n\t\t\t}\r\n\r\n\t\t\t// linear scale\r\n\t\t\tif ( x >= prevX + labelWidthX / 2 && x <= analyzerWidth ) {\r\n\t\t\t\t_scaleX.fillText( label, isDualHorizontal && _mirror == -1 ? analyzerWidth - x : initialX + x, y, maxW );\r\n\t\t\t\tif ( isDualHorizontal || ( _mirror && ( x > labelWidthX || _mirror == 1 ) ) )\r\n\t\t\t\t\t_scaleX.fillText( label, isDualHorizontal && _mirror != 1 ? analyzerWidth + x : ( initialX || canvas.width ) - x, y, maxW );\r\n\t\t\t\tprevX = x + Math.min( maxW, _scaleX.measureText( label ).width ) / 2;\r\n\t\t\t}\r\n\r\n\t\t\t// radial scale\r\n\t\t\tif ( x >= prevR + labelWidthR && x < analyzerWidth - labelWidthR ) { // avoid overlapping the last label over the first one\r\n\t\t\t\tradialLabel( isDualHorizontal && _mirror == 1 ? analyzerWidth - x : x, label );\r\n\t\t\t\tif ( isDualHorizontal || ( _mirror && ( x > labelWidthR || _mirror == 1 ) ) ) // avoid overlapping of first labels on mirror mode\r\n\t\t\t\t\tradialLabel( isDualHorizontal && _mirror != -1 ? analyzerWidth + x : -x, label );\r\n\t\t\t\tprevR = x;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Redraw the canvas\r\n\t * this is called 60 times per second by requestAnimationFrame()\r\n\t */\r\n\t_draw( timestamp ) {\r\n\t\t// schedule next canvas update\r\n\t\tthis._runId = requestAnimationFrame( timestamp => this._draw( timestamp ) );\r\n\r\n\t\t// frame rate control\r\n\t\tconst elapsed        = timestamp - this._time, // time since last FPS computation\r\n\t\t\t  frameTime      = timestamp - this._last, // time since last rendered frame\r\n\t\t\t  targetInterval = this._maxFPS ? 975 / this._maxFPS : 0; // small tolerance for best results\r\n\r\n\t\tif ( frameTime < targetInterval )\r\n\t\t\treturn;\r\n\r\n\t\tthis._last = timestamp - ( targetInterval ? frameTime % targetInterval : 0 ); // thanks https://stackoverflow.com/a/19772220/2370385\r\n\t\tthis._frames++;\r\n\r\n\t\tif ( elapsed >= 1000 ) { // update FPS every second\r\n\t\t\tthis._fps = this._frames / elapsed * 1000;\r\n\t\t\tthis._frames = 0;\r\n\t\t\tthis._time = timestamp;\r\n\t\t}\r\n\r\n\t\t// initialize local constants\r\n\r\n\t\tconst { isAlpha,\r\n\t\t\t    isBands,\r\n\t\t\t    isLeds,\r\n\t\t\t    isLumi,\r\n\t\t\t    isOctaves,\r\n\t\t\t    isOutline,\r\n\t\t\t    isRound,\r\n\t\t\t    noLedGap }     = this._flg,\r\n\r\n\t\t\t  { analyzerHeight,\r\n\t\t\t    centerX,\r\n\t\t\t    centerY,\r\n\t\t\t    channelCoords,\r\n\t\t\t    channelHeight,\r\n\t\t\t    channelGap,\r\n\t\t\t    initialX,\r\n\t\t\t    innerRadius,\r\n\t\t\t    outerRadius }  = this._aux,\r\n\r\n\t\t\t  { _bars,\r\n\t\t\t    canvas,\r\n\t\t\t    _canvasGradients,\r\n\t\t\t    _chLayout,\r\n\t\t\t    _colorMode,\r\n\t\t\t    _ctx,\r\n\t\t\t    _energy,\r\n\t\t\t    _fadePeaks,\r\n\t\t\t    fillAlpha,\r\n\t\t\t    _fps,\r\n\t\t\t    _linearAmplitude,\r\n\t\t\t    _lineWidth,\r\n\t\t\t    maxDecibels,\r\n\t\t\t    minDecibels,\r\n\t\t\t    _mirror,\r\n\t\t\t    _mode,\r\n\t\t\t    overlay,\r\n\t\t\t    _radial,\r\n\t\t\t    showBgColor,\r\n\t\t\t    showPeaks,\r\n\t\t\t    useCanvas,\r\n\t\t\t    _weightingFilter } = this,\r\n\r\n\t\t\t  canvasX          = this._scaleX.canvas,\r\n\t\t\t  canvasR          = this._scaleR.canvas,\r\n\t\t\t  fadeFrames       = _fps * this._peakFadeTime / 1e3,\r\n\t\t\t  fpsSquared       = _fps ** 2,\r\n\t\t\t  gravity          = this._gravity * 1e3,\r\n\t\t\t  holdFrames       = _fps * this._peakHoldTime / 1e3,\r\n\t\t\t  isDualCombined   = _chLayout == CHANNEL_COMBINED,\r\n\t\t\t  isDualHorizontal = _chLayout == CHANNEL_HORIZONTAL,\r\n\t\t\t  isDualVertical   = _chLayout == CHANNEL_VERTICAL,\r\n\t\t\t  isSingle         = _chLayout == CHANNEL_SINGLE,\r\n\t\t\t  isTrueLeds       = isLeds && this._trueLeds && _colorMode == COLOR_GRADIENT,\r\n\t\t\t  analyzerWidth    = _radial ? canvas.width : this._aux.analyzerWidth,\r\n\t\t\t  finalX           = initialX + analyzerWidth,\r\n\t\t\t  showPeakLine     = showPeaks && this._peakLine && _mode == MODE_GRAPH,\r\n\t\t\t  maxBarHeight     = _radial ? outerRadius - innerRadius : analyzerHeight,\r\n\t\t\t  nominalMaxHeight = maxBarHeight / this._pixelRatio, // for consistent gravity on lo-res or hi-dpi\r\n\t\t\t  dbRange \t\t   = maxDecibels - minDecibels,\r\n\t\t\t  [ ledCount, ledSpaceH, ledSpaceV, ledHeight ] = this._leds || [];\r\n\r\n\t\tif ( _energy.val > 0 && _fps > 0 )\r\n\t\t\tthis._spinAngle += this._spinSpeed * TAU / 60 / _fps; // spinSpeed * angle increment per frame for 1 RPM\r\n\r\n\t\t/* HELPER FUNCTIONS */\r\n\r\n\t\t// create Reflex effect\r\n\t\tconst doReflex = channel => {\r\n\t\t\tif ( this._reflexRatio > 0 && ! isLumi && ! _radial ) {\r\n\t\t\t\tlet posY, height;\r\n\t\t\t\tif ( this.reflexFit || isDualVertical ) { // always fit reflex in vertical stereo mode\r\n\t\t\t\t\tposY   = isDualVertical && channel == 0 ? channelHeight + channelGap : 0;\r\n\t\t\t\t\theight = channelHeight - analyzerHeight;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tposY   = canvas.height - analyzerHeight * 2;\r\n\t\t\t\t\theight = analyzerHeight;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_ctx.save();\r\n\r\n\t\t\t\t// set alpha and brightness for the reflection\r\n\t\t\t\t_ctx.globalAlpha = this.reflexAlpha;\r\n\t\t\t\tif ( this.reflexBright != 1 )\r\n\t\t\t\t\t_ctx.filter = `brightness(${this.reflexBright})`;\r\n\r\n\t\t\t\t// create the reflection\r\n\t\t\t\t_ctx.setTransform( 1, 0, 0, -1, 0, canvas.height );\r\n\t\t\t\t_ctx.drawImage( canvas, 0, channelCoords[ channel ].channelTop, canvas.width, analyzerHeight, 0, posY, canvas.width, height );\r\n\r\n\t\t\t\t_ctx.restore();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// draw scale on X-axis\r\n\t\tconst drawScaleX = () => {\r\n\t\t\tif ( this.showScaleX ) {\r\n\t\t\t\tif ( _radial ) {\r\n\t\t\t\t\t_ctx.save();\r\n\t\t\t\t\t_ctx.translate( centerX, centerY );\r\n\t\t\t\t\tif ( this._spinSpeed )\r\n\t\t\t\t\t\t_ctx.rotate( this._spinAngle + HALF_PI );\r\n\t\t\t\t\t_ctx.drawImage( canvasR, -canvasR.width >> 1, -canvasR.width >> 1 );\r\n\t\t\t\t\t_ctx.restore();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\t_ctx.drawImage( canvasX, 0, canvas.height - canvasX.height );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// returns the gain (in dB) for a given frequency, considering the currently selected weighting filter\r\n\t\tconst weightingdB = freq => {\r\n\t\t\tconst f2 = freq ** 2,\r\n\t\t\t\t  SQ20_6  = 424.36,\r\n\t\t\t\t  SQ107_7 = 11599.29,\r\n\t\t\t\t  SQ158_5 = 25122.25,\r\n\t\t\t\t  SQ737_9 = 544496.41,\r\n\t\t\t\t  SQ12194 = 148693636,\r\n\t\t\t\t  linearTodB = value => 20 * Math.log10( value );\r\n\r\n\t\t\tswitch ( _weightingFilter ) {\r\n\t\t\t\tcase FILTER_A : // A-weighting https://en.wikipedia.org/wiki/A-weighting\r\n\t\t\t\t\tconst rA = ( SQ12194 * f2 ** 2 ) / ( ( f2 + SQ20_6 ) * Math.sqrt( ( f2 + SQ107_7 ) * ( f2 + SQ737_9 ) ) * ( f2 + SQ12194 ) );\r\n\t\t\t\t\treturn 2 + linearTodB( rA );\r\n\r\n\t\t\t\tcase FILTER_B :\r\n\t\t\t\t\tconst rB = ( SQ12194 * f2 * freq ) / ( ( f2 + SQ20_6 ) * Math.sqrt( f2 + SQ158_5 ) * ( f2 + SQ12194 ) );\r\n\t\t\t\t\treturn .17 + linearTodB( rB );\r\n\r\n\t\t\t\tcase FILTER_C :\r\n\t\t\t\t\tconst rC = ( SQ12194 * f2 ) / ( ( f2 + SQ20_6 ) * ( f2 + SQ12194 ) );\r\n\t\t\t\t\treturn .06 + linearTodB( rC );\r\n\r\n\t\t\t\tcase FILTER_D :\r\n\t\t\t\t\tconst h = ( ( 1037918.48 - f2 ) ** 2 + 1080768.16 * f2 ) / ( ( 9837328 - f2 ) ** 2 + 11723776 * f2 ),\r\n\t\t\t\t\t\t  rD = ( freq / 6.8966888496476e-5 ) * Math.sqrt( h / ( ( f2 + 79919.29 ) * ( f2 + 1345600 ) ) );\r\n\t\t\t\t\treturn linearTodB( rD );\r\n\r\n\t\t\t\tcase FILTER_468 : // ITU-R 468 https://en.wikipedia.org/wiki/ITU-R_468_noise_weighting\r\n\t\t\t\t\tconst h1 = -4.737338981378384e-24 * freq ** 6 + 2.043828333606125e-15 * freq ** 4 - 1.363894795463638e-7 * f2 + 1,\r\n\t\t\t\t\t\t  h2 = 1.306612257412824e-19 * freq ** 5 - 2.118150887518656e-11 * freq ** 3 + 5.559488023498642e-4 * freq,\r\n\t\t\t\t\t\t  rI = 1.246332637532143e-4 * freq / Math.hypot( h1, h2 );\r\n\t\t\t\t\treturn 18.2 + linearTodB( rI );\r\n\t\t\t}\r\n\r\n\t\t\treturn 0; // unknown filter\r\n\t\t}\r\n\r\n\t\t// draws (stroke) a bar from x,y1 to x,y2\r\n\t\tconst strokeBar = ( x, y1, y2 ) => {\r\n\t\t\t_ctx.beginPath();\r\n\t\t\t_ctx.moveTo( x, y1 );\r\n\t\t\t_ctx.lineTo( x, y2 );\r\n\t\t\t_ctx.stroke();\r\n\t\t}\r\n\r\n\t\t// conditionally strokes current path on canvas\r\n\t\tconst strokeIf = flag => {\r\n\t\t\tif ( flag && _lineWidth ) {\r\n\t\t\t\tconst alpha = _ctx.globalAlpha;\r\n\t\t\t\t_ctx.globalAlpha = 1;\r\n\t\t\t\t_ctx.stroke();\r\n\t\t\t\t_ctx.globalAlpha = alpha;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// converts a value in [0;1] range to a height in pixels that fits into the current LED elements\r\n\t\tconst ledPosY = value => Math.max( 0, ( value * ledCount | 0 ) * ( ledHeight + ledSpaceV ) - ledSpaceV );\r\n\r\n\t\t// update energy information\r\n\t\tconst updateEnergy = newVal => {\r\n\t\t\t_energy.val = newVal;\r\n\t\t\tif ( _energy.peak > 0 ) {\r\n\t\t\t\t_energy.hold--;\r\n\t\t\t\tif ( _energy.hold < 0 )\r\n\t\t\t\t\t_energy.peak += _energy.hold * gravity / fpsSquared / canvas.height * this._pixelRatio;\r\n\t\t\t\t\t// TO-DO: replace `canvas.height * this._pixelRatio` with `maxNominalHeight` when implementing dual-channel energy\r\n\t\t\t}\r\n\t\t\tif ( newVal >= _energy.peak ) {\r\n\t\t\t\t_energy.peak = newVal;\r\n\t\t\t\t_energy.hold = holdFrames;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* MAIN FUNCTION */\r\n\r\n\t\tif ( overlay )\r\n\t\t\t_ctx.clearRect( 0, 0, canvas.width, canvas.height );\r\n\r\n\t\tlet currentEnergy = 0;\r\n\r\n\t\tconst nBars     = _bars.length,\r\n\t\t\t  nChannels = isSingle ? 1 : 2;\r\n\r\n\t\tfor ( let channel = 0; channel < nChannels; channel++ ) {\r\n\r\n\t\t\tconst { channelTop, channelBottom, analyzerBottom } = channelCoords[ channel ],\r\n\t\t\t\t  channelGradient  = this._gradients[ this._selectedGrads[ channel ] ],\r\n\t\t\t\t  colorStops       = channelGradient.colorStops,\r\n\t\t\t\t  colorCount       = colorStops.length,\r\n\t\t\t\t  bgColor          = ( ! showBgColor || isLeds && ! overlay ) ? '#000' : channelGradient.bgColor,\r\n\t\t\t\t  radialDirection  = isDualVertical && _radial && channel ? -1 : 1, // 1 = outwards, -1 = inwards\r\n\t\t\t\t  invertedChannel  = ( ! channel && _mirror == -1 ) || ( channel && _mirror == 1 ),\r\n\t\t\t\t  radialOffsetX    = ! isDualHorizontal || ( channel && _mirror != 1 ) ? 0 : analyzerWidth >> ( channel || ! invertedChannel ),\r\n\t\t\t\t  angularDirection = isDualHorizontal && invertedChannel ? -1 : 1;  // 1 = clockwise, -1 = counterclockwise\r\n/*\r\n\t\t\tExpanded logic for radialOffsetX and angularDirection:\r\n\r\n\t\t\tlet radialOffsetX = 0,\r\n\t\t\t\tangularDirection = 1;\r\n\r\n\t\t\tif ( isDualHorizontal ) {\r\n\t\t\t\tif ( channel == 0 ) { // LEFT channel\r\n\t\t\t\t\tif ( _mirror == -1 ) {\r\n\t\t\t\t\t\tradialOffsetX = analyzerWidth;\r\n\t\t\t\t\t\tangularDirection = -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tradialOffsetX = analyzerWidth >> 1;\r\n\t\t\t\t}\r\n\t\t\t\telse {                // RIGHT channel\r\n\t\t\t\t\tif ( _mirror == 1 ) {\r\n\t\t\t\t\t\tradialOffsetX = analyzerWidth >> 1;\r\n\t\t\t\t\t\tangularDirection = -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n*/\r\n\t\t\t// draw scale on Y-axis (uses: channel, channelTop)\r\n\t\t\tconst drawScaleY = () => {\r\n\t\t\t\tconst scaleWidth = canvasX.height,\r\n\t\t\t\t\t  fontSize   = scaleWidth >> 1,\r\n\t\t\t\t\t  max        = _linearAmplitude ? 100 : maxDecibels,\r\n\t\t\t\t\t  min        = _linearAmplitude ? 0 : minDecibels,\r\n\t\t\t\t\t  incr       = _linearAmplitude ? 20 : 5,\r\n\t\t\t\t\t  interval   = analyzerHeight / ( max - min ),\r\n\t\t\t\t\t  atStart    = _mirror != -1 && ( ! isDualHorizontal || channel == 0 || _mirror == 1 ),\r\n\t\t\t\t\t  atEnd      = _mirror != 1 && ( ! isDualHorizontal || channel != _mirror );\r\n\r\n\t\t\t\t_ctx.save();\r\n\t\t\t\t_ctx.fillStyle = SCALEY_LABEL_COLOR;\r\n\t\t\t\t_ctx.font = `${fontSize}px ${FONT_FAMILY}`;\r\n\t\t\t\t_ctx.textAlign = 'right';\r\n\t\t\t\t_ctx.lineWidth = 1;\r\n\r\n\t\t\t\tfor ( let val = max; val > min; val -= incr ) {\r\n\t\t\t\t\tconst posY = channelTop + ( max - val ) * interval,\r\n\t\t\t\t\t\t  even = ( val % 2 == 0 ) | 0;\r\n\r\n\t\t\t\t\tif ( even ) {\r\n\t\t\t\t\t\tconst labelY = posY + fontSize * ( posY == channelTop ? .8 : .35 );\r\n\t\t\t\t\t\tif ( atStart )\r\n\t\t\t\t\t\t\t_ctx.fillText( val, scaleWidth * .85, labelY );\r\n\t\t\t\t\t\tif ( atEnd )\r\n\t\t\t\t\t\t\t_ctx.fillText( val, ( isDualHorizontal ? analyzerWidth : canvas.width ) - scaleWidth * .1, labelY );\r\n\t\t\t\t\t\t_ctx.strokeStyle = SCALEY_LABEL_COLOR;\r\n\t\t\t\t\t\t_ctx.setLineDash([2,4]);\r\n\t\t\t\t\t\t_ctx.lineDashOffset = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t_ctx.strokeStyle = SCALEY_MIDLINE_COLOR;\r\n\t\t\t\t\t\t_ctx.setLineDash([2,8]);\r\n\t\t\t\t\t\t_ctx.lineDashOffset = 1;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_ctx.beginPath();\r\n\t\t\t\t\t_ctx.moveTo( initialX + scaleWidth * even * atStart, ~~posY + .5 ); // for sharp 1px line (https://stackoverflow.com/a/13879402/2370385)\r\n\t\t\t\t\t_ctx.lineTo( finalX - scaleWidth * even * atEnd, ~~posY + .5 );\r\n\t\t\t\t\t_ctx.stroke();\r\n\t\t\t\t}\r\n\t\t\t\t_ctx.restore();\r\n\t\t\t}\r\n\r\n\t\t\t// FFT bin data interpolation (uses fftData)\r\n\t\t\tconst interpolate = ( bin, ratio ) => {\r\n\t\t\t\tconst value = fftData[ bin ] + ( bin < fftData.length - 1 ? ( fftData[ bin + 1 ] - fftData[ bin ] ) * ratio : 0 );\r\n\t\t\t\treturn isNaN( value ) ? -Infinity : value;\r\n\t\t\t}\r\n\r\n\t\t\t// converts a given X-coordinate to its corresponding angle in radial mode (uses angularDirection)\r\n\t\t\tconst getAngle = ( x, dir = angularDirection ) => dir * TAU * ( ( x + radialOffsetX ) / canvas.width ) + this._spinAngle;\r\n\r\n\t\t\t// converts planar X,Y coordinates to radial coordinates (uses: getAngle(), radialDirection)\r\n\t\t\tconst radialXY = ( x, y, dir ) => {\r\n\t\t\t\tconst height = innerRadius + y * radialDirection,\r\n\t\t\t\t\t  angle  = getAngle( x, dir );\r\n\t\t\t\treturn [ centerX + height * Math.cos( angle ), centerY + height * Math.sin( angle ) ];\r\n\t\t\t}\r\n\r\n\t\t\t// draws a polygon of width `w` and height `h` at (x,y) in radial mode (uses: angularDirection, radialDirection)\r\n\t\t\tconst radialPoly = ( x, y, w, h, stroke ) => {\r\n\t\t\t\t_ctx.beginPath();\r\n\t\t\t\tfor ( const dir of ( _mirror && ! isDualHorizontal ? [1,-1] : [ angularDirection ] ) ) {\r\n\t\t\t\t\tconst [ startAngle, endAngle ] = isRound ? [ getAngle( x, dir ), getAngle( x + w, dir ) ] : [];\r\n\t\t\t\t\t_ctx.moveTo( ...radialXY( x, y, dir ) );\r\n\t\t\t\t\t_ctx.lineTo( ...radialXY( x, y + h, dir ) );\r\n\t\t\t\t\tif ( isRound )\r\n\t\t\t\t\t\t_ctx.arc( centerX, centerY, innerRadius + ( y + h ) * radialDirection, startAngle, endAngle, dir != 1 );\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t_ctx.lineTo( ...radialXY( x + w, y + h, dir ) );\r\n\t\t\t\t\t_ctx.lineTo( ...radialXY( x + w, y, dir ) );\r\n\t\t\t\t\tif ( isRound && ! stroke ) // close the bottom line only when not in outline mode\r\n\t\t\t\t\t\t_ctx.arc( centerX, centerY, innerRadius + y * radialDirection, endAngle, startAngle, dir == 1 );\r\n\t\t\t\t}\r\n\t\t\t\tstrokeIf( stroke );\r\n\t\t\t\t_ctx.fill();\r\n\t\t\t}\r\n\r\n\t\t\t// set fillStyle and strokeStyle according to current colorMode (uses: channel, colorStops, colorCount)\r\n\t\t\tconst setBarColor = ( value = 0, barIndex = 0 ) => {\r\n\t\t\t\tlet color;\r\n\t\t\t\t// for graph mode, always use the channel gradient (ignore colorMode)\r\n\t\t\t\tif ( ( _colorMode == COLOR_GRADIENT && ! isTrueLeds ) || _mode == MODE_GRAPH )\r\n\t\t\t\t\tcolor = _canvasGradients[ channel ];\r\n\t\t\t\telse {\r\n\t\t\t\t\tconst selectedIndex = _colorMode == COLOR_BAR_INDEX ? barIndex % colorCount : colorStops.findLastIndex( item => isLeds ? ledPosY( value ) <= ledPosY( item.level ) : value <= item.level );\r\n\t\t\t\t\tcolor = colorStops[ selectedIndex ].color;\r\n\t\t\t\t}\r\n\t\t\t\t_ctx.fillStyle = _ctx.strokeStyle = color;\r\n\t\t\t}\r\n\r\n\t\t\t// CHANNEL START\r\n\r\n\t\t\tif ( useCanvas ) {\r\n\t\t\t\t// set transform (horizontal flip and translation) for dual-horizontal layout\r\n\t\t\t\tif ( isDualHorizontal && ! _radial ) {\r\n\t\t\t\t  \tconst translateX = analyzerWidth * ( channel + invertedChannel ),\r\n\t\t\t\t  \t\t  flipX      = invertedChannel ? -1 : 1;\r\n\r\n\t\t\t\t\t_ctx.setTransform( flipX, 0, 0, 1, translateX, 0 );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// fill the analyzer background if needed (not overlay or overlay + showBgColor)\r\n\t\t\t\tif ( ! overlay || showBgColor ) {\r\n\t\t\t\t\tif ( overlay )\r\n\t\t\t\t\t\t_ctx.globalAlpha = this.bgAlpha;\r\n\r\n\t\t\t\t\t_ctx.fillStyle = bgColor;\r\n\r\n\t\t\t\t\t// exclude the reflection area when overlay is true and reflexAlpha == 1 (avoids alpha over alpha difference, in case bgAlpha < 1)\r\n\t\t\t\t\tif ( channel == 0 || ( ! _radial && ! isDualCombined ) )\r\n\t\t\t\t\t\t_ctx.fillRect( initialX, channelTop - channelGap, analyzerWidth, ( overlay && this.reflexAlpha == 1 ? analyzerHeight : channelHeight ) + channelGap );\r\n\r\n\t\t\t\t\t_ctx.globalAlpha = 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// draw dB scale (Y-axis) - avoid drawing it twice on 'dual-combined' channel layout\r\n\t\t\t\tif ( this.showScaleY && ! isLumi && ! _radial && ( channel == 0 || ! isDualCombined ) )\r\n\t\t\t\t\tdrawScaleY();\r\n\r\n\t\t\t\t// set line width and dash for LEDs effect\r\n\t\t\t\tif ( isLeds ) {\r\n\t\t\t\t\t_ctx.setLineDash( [ ledHeight, ledSpaceV ] );\r\n\t\t\t\t\t_ctx.lineWidth = _bars[0].width;\r\n\t\t\t\t}\r\n\t\t\t\telse // for outline effect ensure linewidth is not greater than half the bar width\r\n\t\t\t\t\t_ctx.lineWidth = isOutline ? Math.min( _lineWidth, _bars[0].width / 2 ) : _lineWidth;\r\n\r\n\t\t\t\t// set clipping region\r\n\t\t\t\t_ctx.save();\r\n\t\t\t\tif ( ! _radial ) {\r\n\t\t\t\t\tconst region = new Path2D();\r\n\t\t\t\t\tregion.rect( 0, channelTop, canvas.width, analyzerHeight );\r\n\t\t\t\t\t_ctx.clip( region );\r\n\t\t\t\t}\r\n\r\n\t\t\t} // if ( useCanvas )\r\n\r\n\t\t\t// get a new array of data from the FFT\r\n\t\t\tlet fftData = this._fftData[ channel ];\r\n\t\t\tthis._analyzer[ channel ].getFloatFrequencyData( fftData );\r\n\r\n\t\t\t// apply weighting\r\n\t\t\tif ( _weightingFilter )\r\n\t\t\t\tfftData = fftData.map( ( val, idx ) => val + weightingdB( this._binToFreq( idx ) ) );\r\n\r\n\t\t\t// start drawing path (for graph mode)\r\n\t\t\t_ctx.beginPath();\r\n\r\n\t\t\t// store line graph points to create mirror effect in radial mode\r\n\t\t\tlet points = [];\r\n\r\n\t\t\t// draw bars / lines\r\n\r\n\t\t\tfor ( let barIndex = 0; barIndex < nBars; barIndex++ ) {\r\n\r\n\t\t\t\tconst bar = _bars[ barIndex ],\r\n\t\t\t\t\t  { posX, barCenter, width, freq, binLo, binHi, ratioLo, ratioHi } = bar;\r\n\r\n\t\t\t\tlet barValue = Math.max( interpolate( binLo, ratioLo ), interpolate( binHi, ratioHi ) );\r\n\r\n\t\t\t\t// check additional bins (if any) for this bar and keep the highest value\r\n\t\t\t\tfor ( let j = binLo + 1; j < binHi; j++ ) {\r\n\t\t\t\t\tif ( fftData[ j ] > barValue )\r\n\t\t\t\t\t\tbarValue = fftData[ j ];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// normalize bar amplitude in [0;1] range\r\n\t\t\t\tbarValue = this._normalizedB( barValue );\r\n\r\n\t\t\t\tbar.value[ channel ] = barValue;\r\n\t\t\t\tcurrentEnergy += barValue;\r\n\r\n\t\t\t\t// update bar peak\r\n\t\t\t\tif ( bar.peak[ channel ] > 0 && bar.alpha[ channel ] > 0 ) {\r\n\t\t\t\t\tbar.hold[ channel ]--;\r\n\t\t\t\t\t// if hold is negative, start peak drop or fade out\r\n\t\t\t\t\tif ( bar.hold[ channel ] < 0 ) {\r\n\t\t\t\t\t\tif ( _fadePeaks && ! showPeakLine ) {\r\n\t\t\t\t\t\t\tconst initialAlpha = ! isAlpha || ( isOutline && _lineWidth > 0 ) ? 1 : isAlpha ? bar.peak[ channel ] : fillAlpha;\r\n\t\t\t\t\t\t\tbar.alpha[ channel ] = initialAlpha * ( 1 + bar.hold[ channel ] / fadeFrames ); // hold is negative, so this is <= 1\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tbar.peak[ channel ] += bar.hold[ channel ] * gravity / fpsSquared / nominalMaxHeight;\r\n\t\t\t\t\t\t// make sure the peak value is reset when using fadePeaks\r\n\t\t\t\t\t\tif ( bar.alpha[ channel ] <= 0 )\r\n\t\t\t\t\t\t\tbar.peak[ channel ] = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// check if it's a new peak for this bar\r\n\t\t\t\tif ( barValue >= bar.peak[ channel ] ) {\r\n\t\t\t\t\tbar.peak[ channel ] = barValue;\r\n\t\t\t\t\tbar.hold[ channel ] = holdFrames;\r\n\t\t\t\t\t// check whether isAlpha or isOutline are active to start the peak alpha with the proper value\r\n\t\t\t\t\tbar.alpha[ channel ] = ! isAlpha || ( isOutline && _lineWidth > 0 ) ? 1 : isAlpha ? barValue : fillAlpha;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if not using the canvas, move earlier to the next bar\r\n\t\t\t\tif ( ! useCanvas )\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t// set opacity for bar effects\r\n\t\t\t\t_ctx.globalAlpha = ( isLumi || isAlpha ) ? barValue : ( isOutline ) ? fillAlpha : 1;\r\n\r\n\t\t\t\t// set fillStyle and strokeStyle for the current bar\r\n\t\t\t\tsetBarColor( barValue, barIndex );\r\n\r\n\t\t\t\t// compute actual bar height on screen\r\n\t\t\t\tconst barHeight = isLumi ? maxBarHeight : isLeds ? ledPosY( barValue ) : barValue * maxBarHeight | 0;\r\n\r\n\t\t\t\t// Draw current bar or line segment\r\n\r\n\t\t\t\tif ( _mode == MODE_GRAPH ) {\r\n\t\t\t\t\t// compute the average between the initial bar (barIndex==0) and the next one\r\n\t\t\t\t\t// used to smooth the curve when the initial posX is off the screen, in mirror and radial modes\r\n\t\t\t\t\tconst nextBarAvg = barIndex ? 0 : ( this._normalizedB( fftData[ _bars[1].binLo ] ) * maxBarHeight + barHeight ) / 2;\r\n\r\n\t\t\t\t\tif ( _radial ) {\r\n\t\t\t\t\t\tif ( barIndex == 0 ) {\r\n\t\t\t\t\t\t\tif ( isDualHorizontal )\r\n\t\t\t\t\t\t\t\t_ctx.moveTo( ...radialXY( 0, 0 ) );\r\n\t\t\t\t\t\t\t_ctx.lineTo( ...radialXY( 0, ( posX < 0 ? nextBarAvg : barHeight ) ) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// draw line to the current point, avoiding overlapping wrap-around frequencies\r\n\t\t\t\t\t\tif ( posX >= 0 ) {\r\n\t\t\t\t\t\t\tconst point = [ posX, barHeight ];\r\n\t\t\t\t\t\t\t_ctx.lineTo( ...radialXY( ...point ) );\r\n\t\t\t\t\t\t\tpoints.push( point );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse { // Linear\r\n\t\t\t\t\t\tif ( barIndex == 0 ) {\r\n\t\t\t\t\t\t\t// start the line off-screen using the previous FFT bin value as the initial amplitude\r\n\t\t\t\t\t\t\tif ( _mirror == -1 && ! isDualHorizontal )\r\n\t\t\t\t\t\t\t\t_ctx.moveTo( initialX, analyzerBottom - ( posX < initialX ? nextBarAvg : barHeight ) );\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tconst prevFFTData = binLo ? this._normalizedB( fftData[ binLo - 1 ] ) * maxBarHeight : barHeight; // use previous FFT bin value, when available\r\n\t\t\t\t\t\t\t\t_ctx.moveTo( initialX - _lineWidth, analyzerBottom - prevFFTData );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// draw line to the current point\r\n\t\t\t\t\t\t// avoid X values lower than the origin when mirroring left, otherwise draw them for best graph accuracy\r\n\t\t\t\t\t\tif ( isDualHorizontal || _mirror != -1 || posX >= initialX )\r\n\t\t\t\t\t\t\t_ctx.lineTo( posX, analyzerBottom - barHeight );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif ( isLeds ) {\r\n\t\t\t\t\t\t// draw \"unlit\" leds - avoid drawing it twice on 'dual-combined' channel layout\r\n\t\t\t\t\t\tif ( showBgColor && ! overlay && ( channel == 0 || ! isDualCombined ) ) {\r\n\t\t\t\t\t\t\tconst alpha = _ctx.globalAlpha;\r\n\t\t\t\t\t\t\t_ctx.strokeStyle = LEDS_UNLIT_COLOR;\r\n\t\t\t\t\t\t\t_ctx.globalAlpha = 1;\r\n\t\t\t\t\t\t\tstrokeBar( barCenter, channelTop, analyzerBottom );\r\n\t\t\t\t\t\t\t// restore properties\r\n\t\t\t\t\t\t\t_ctx.strokeStyle = _ctx.fillStyle;\r\n\t\t\t\t\t\t\t_ctx.globalAlpha = alpha;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( isTrueLeds ) {\r\n\t\t\t\t\t\t\t// ledPosY() is used below to fit one entire led height into the selected range\r\n\t\t\t\t\t\t\tconst colorIndex = isLumi ? 0 : colorStops.findLastIndex( item => ledPosY( barValue ) <= ledPosY( item.level ) );\r\n\t\t\t\t\t\t\tlet last = analyzerBottom;\r\n\t\t\t\t\t\t\tfor ( let i = colorCount - 1; i >= colorIndex; i-- ) {\r\n\t\t\t\t\t\t\t\t_ctx.strokeStyle = colorStops[ i ].color;\r\n\t\t\t\t\t\t\t\tlet y = analyzerBottom - ( i == colorIndex ? barHeight : ledPosY( colorStops[ i ].level ) );\r\n\t\t\t\t\t\t\t\tstrokeBar( barCenter, last, y );\r\n\t\t\t\t\t\t\t\tlast = y - ledSpaceV;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tstrokeBar( barCenter, analyzerBottom, analyzerBottom - barHeight );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ( posX >= initialX ) {\r\n\t\t\t\t\t\tif ( _radial )\r\n\t\t\t\t\t\t\tradialPoly( posX, 0, width, barHeight, isOutline );\r\n\t\t\t\t\t\telse if ( isRound ) {\r\n\t\t\t\t\t\t\tconst halfWidth = width / 2,\r\n\t\t\t\t\t\t\t\t  y = analyzerBottom + halfWidth; // round caps have an additional height of half bar width\r\n\r\n\t\t\t\t\t\t\t_ctx.beginPath();\r\n\t\t\t\t\t\t\t_ctx.moveTo( posX, y );\r\n\t\t\t\t\t\t\t_ctx.lineTo( posX, y - barHeight );\r\n\t\t\t\t\t\t\t_ctx.arc( barCenter, y - barHeight, halfWidth, PI, TAU );\r\n\t\t\t\t\t\t\t_ctx.lineTo( posX + width, y );\r\n\t\t\t\t\t\t\tstrokeIf( isOutline );\r\n\t\t\t\t\t\t\t_ctx.fill();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tconst offset = isOutline ? _ctx.lineWidth : 0;\r\n\t\t\t\t\t\t\t_ctx.beginPath();\r\n\t\t\t\t\t\t\t_ctx.rect( posX, analyzerBottom + offset, width, -barHeight - offset );\r\n\t\t\t\t\t\t\tstrokeIf( isOutline );\r\n\t\t\t\t\t\t\t_ctx.fill();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Draw peak\r\n\t\t\t\tconst peakValue = bar.peak[ channel ],\r\n\t\t\t\t\t  peakAlpha = bar.alpha[ channel ];\r\n\r\n\t\t\t\tif ( peakValue > 0 && peakAlpha > 0 && showPeaks && ! showPeakLine && ! isLumi && posX >= initialX && posX < finalX ) {\r\n\t\t\t\t\t// set opacity for peak\r\n\t\t\t\t\tif ( _fadePeaks )\r\n\t\t\t\t\t\t_ctx.globalAlpha = peakAlpha;\r\n\t\t\t\t\telse if ( isOutline && _lineWidth > 0 ) // when lineWidth == 0 ctx.globalAlpha remains set to `fillAlpha`\r\n\t\t\t\t\t\t_ctx.globalAlpha = 1;\r\n\t\t\t\t\telse if ( isAlpha )\t\t\t\t\t\t// isAlpha (alpha based on peak value) supersedes fillAlpha if lineWidth == 0\r\n\t\t\t\t\t\t_ctx.globalAlpha = peakValue;\r\n\r\n\t\t\t\t\t// select the peak color for 'bar-level' colorMode or 'trueLeds'\r\n\t\t\t\t\tif ( _colorMode == COLOR_BAR_LEVEL || isTrueLeds )\r\n\t\t\t\t\t\tsetBarColor( peakValue );\r\n\r\n\t\t\t\t\t// render peak according to current mode / effect\r\n\t\t\t\t\tif ( isLeds ) {\r\n\t\t\t\t\t\tconst ledPeak = ledPosY( peakValue );\r\n\t\t\t\t\t\tif ( ledPeak >= ledSpaceV ) // avoid peak below first led\r\n\t\t\t\t\t\t\t_ctx.fillRect( posX, analyzerBottom - ledPeak, width, ledHeight );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ( ! _radial )\r\n\t\t\t\t\t\t_ctx.fillRect( posX, analyzerBottom - peakValue * maxBarHeight, width, 2 );\r\n\t\t\t\t\telse if ( _mode != MODE_GRAPH ) { // radial (peaks for graph mode are done by the peakLine code)\r\n\t\t\t\t\t\tconst y = peakValue * maxBarHeight;\r\n\t\t\t\t\t\tradialPoly( posX, y, width, ! this._radialInvert || isDualVertical || y + innerRadius >= 2 ? -2 : 2 );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t} // for ( let barIndex = 0; barIndex < nBars; barIndex++ )\r\n\r\n\t\t\t// if not using the canvas, move earlier to the next channel\r\n\t\t\tif ( ! useCanvas )\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t// restore global alpha\r\n\t\t\t_ctx.globalAlpha = 1;\r\n\r\n\t\t\t// Fill/stroke drawing path for graph mode\r\n\t\t\tif ( _mode == MODE_GRAPH ) {\r\n\t\t\t\tsetBarColor(); // select channel gradient\r\n\r\n\t\t\t\tif ( _radial && ! isDualHorizontal ) {\r\n\t\t\t\t\tif ( _mirror ) {\r\n\t\t\t\t\t\tlet p;\r\n\t\t\t\t\t\twhile ( p = points.pop() )\r\n\t\t\t\t\t\t\t_ctx.lineTo( ...radialXY( ...p, -1 ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t\t_ctx.closePath();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _lineWidth > 0 )\r\n\t\t\t\t\t_ctx.stroke();\r\n\r\n\t\t\t\tif ( fillAlpha > 0 ) {\r\n\t\t\t\t\tif ( _radial ) {\r\n\t\t\t\t\t\t// exclude the center circle from the fill area\r\n\t\t\t\t\t\tconst start = isDualHorizontal ? getAngle( analyzerWidth >> 1 ) : 0,\r\n\t\t\t\t\t\t\t  end   = isDualHorizontal ? getAngle( analyzerWidth ) : TAU;\r\n\t\t\t\t\t\t_ctx.moveTo( ...radialXY( isDualHorizontal ? analyzerWidth >> 1 : 0, 0 ) );\r\n\t\t\t\t\t\t_ctx.arc( centerX, centerY, innerRadius, start, end, isDualHorizontal ? ! invertedChannel : true );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// close the fill area\r\n\t\t\t\t\t\t_ctx.lineTo( finalX, analyzerBottom );\r\n\t\t\t\t\t\t_ctx.lineTo( initialX, analyzerBottom );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_ctx.globalAlpha = fillAlpha;\r\n\t\t\t\t\t_ctx.fill();\r\n\t\t\t\t\t_ctx.globalAlpha = 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// draw peak line (and standard peaks on radial)\r\n\t\t\t\tif ( showPeakLine || ( _radial && showPeaks ) ) {\r\n\t\t\t\t\tpoints = []; // for mirror line on radial\r\n\t\t\t\t\t_ctx.beginPath();\r\n\t\t\t\t\t_bars.forEach( ( b, i ) => {\r\n\t\t\t\t\t\tlet x = b.posX,\r\n\t\t\t\t\t\t\th = b.peak[ channel ],\r\n\t\t\t\t\t\t\tm = i ? 'lineTo' : 'moveTo';\r\n\t\t\t\t\t\tif ( _radial && x < 0 ) {\r\n\t\t\t\t\t\t\tconst nextBar = _bars[ i + 1 ];\r\n\t\t\t\t\t\t\th = findY( x, h, nextBar.posX, nextBar.peak[ channel ], 0 );\r\n\t\t\t\t\t\t\tx = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\th *= maxBarHeight;\r\n\t\t\t\t\t\tif ( showPeakLine ) {\r\n\t\t\t\t\t\t\t_ctx[ m ]( ...( _radial ? radialXY( x, h ) : [ x, analyzerBottom - h ] ) );\r\n\t\t\t\t\t\t\tif ( _radial && _mirror && ! isDualHorizontal )\r\n\t\t\t\t\t\t\t\tpoints.push( [ x, h ] );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if ( h > 0 )\r\n\t\t\t\t\t\t\tradialPoly( x, h, 1, -2 ); // standard peaks (also does mirror)\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif ( showPeakLine ) {\r\n\t\t\t\t\t\tlet p;\r\n\t\t\t\t\t\twhile ( p = points.pop() )\r\n\t\t\t\t\t\t\t_ctx.lineTo( ...radialXY( ...p, -1 ) ); // mirror line points\r\n\t\t\t\t\t\t_ctx.lineWidth = 1;\r\n\t\t\t\t\t\t_ctx.stroke(); // stroke peak line\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t_ctx.restore(); // restore clip region\r\n\r\n\t\t\tif ( isDualHorizontal && ! _radial )\r\n\t\t\t\t_ctx.setTransform( 1, 0, 0, 1, 0, 0 );\r\n\r\n\t\t\t// create Reflex effect - for dual-combined and dual-horizontal do it only once, after channel 1\r\n\t\t\tif ( ( ! isDualHorizontal && ! isDualCombined ) || channel )\r\n\t\t\t\tdoReflex( channel );\r\n\r\n\t\t} // for ( let channel = 0; channel < nChannels; channel++ ) {\r\n\r\n\t\tupdateEnergy( currentEnergy / ( nBars << ( nChannels - 1 ) ) );\r\n\r\n\t\tif ( useCanvas ) {\r\n\t\t\t// Mirror effect\r\n\t\t\tif ( _mirror && ! _radial && ! isDualHorizontal ) {\r\n\t\t\t\t_ctx.setTransform( -1, 0, 0, 1, canvas.width - initialX, 0 );\r\n\t\t\t\t_ctx.drawImage( canvas, initialX, 0, centerX, canvas.height, 0, 0, centerX, canvas.height );\r\n\t\t\t\t_ctx.setTransform( 1, 0, 0, 1, 0, 0 );\r\n\t\t\t}\r\n\r\n\t\t\t// restore solid lines\r\n\t\t\t_ctx.setLineDash([]);\r\n\r\n\t\t\t// draw frequency scale (X-axis)\r\n\t\t\tdrawScaleX();\r\n\t\t}\r\n\r\n\t\t// display current frame rate\r\n\t\tif ( this.showFPS ) {\r\n\t\t\tconst size = canvasX.height;\r\n\t\t\t_ctx.font = `bold ${size}px ${FONT_FAMILY}`;\r\n\t\t\t_ctx.fillStyle = FPS_COLOR;\r\n\t\t\t_ctx.textAlign = 'right';\r\n\t\t\t_ctx.fillText( Math.round( _fps ), canvas.width - size, size * 2 );\r\n\t\t}\r\n\r\n\t\t// call callback function, if defined\r\n\t\tif ( this.onCanvasDraw ) {\r\n\t\t\t_ctx.save();\r\n\t\t\t_ctx.fillStyle = _ctx.strokeStyle = _canvasGradients[0];\r\n\t\t\tthis.onCanvasDraw( this, { timestamp, canvasGradients: _canvasGradients } );\r\n\t\t\t_ctx.restore();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Return scaled frequency according to the selected scale\r\n\t */\r\n\t_freqScaling( freq ) {\r\n\t\tswitch ( this._frequencyScale ) {\r\n\t\t\tcase SCALE_LOG :\r\n\t\t\t\treturn Math.log2( freq );\r\n\t\t\tcase SCALE_BARK :\r\n\t\t\t\treturn ( 26.81 * freq ) / ( 1960 + freq ) - .53;\r\n\t\t\tcase SCALE_MEL :\r\n\t\t\t\treturn Math.log2( 1 + freq / 700 );\r\n\t\t\tcase SCALE_LINEAR :\r\n\t\t\t\treturn freq;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Return the FFT data bin (array index) which represents a given frequency\r\n\t */\r\n\t_freqToBin( freq, method = 'round' ) {\r\n\t\tconst max = this._analyzer[0].frequencyBinCount - 1,\r\n\t\t\t  bin = Math[ method ]( freq * this.fftSize / this.audioCtx.sampleRate );\r\n\r\n\t\treturn bin < max ? bin : max;\r\n\t}\r\n\r\n\t/**\r\n\t * Generate currently selected gradient\r\n\t */\r\n\t_makeGrad() {\r\n\t\tif ( ! this._ready )\r\n\t\t\treturn;\r\n\r\n\t\tconst { canvas, _ctx, _radial, _reflexRatio } = this,\r\n\t\t\t  { analyzerWidth, centerX, centerY, initialX, innerRadius, outerRadius } = this._aux,\r\n\t\t\t  { isLumi }     = this._flg,\r\n\t\t\t  isDualVertical = this._chLayout == CHANNEL_VERTICAL,\r\n\t\t\t  analyzerRatio  = 1 - _reflexRatio,\r\n\t\t\t  gradientHeight = isLumi ? canvas.height : canvas.height * ( 1 - _reflexRatio * ( ! isDualVertical ) ) | 0;\r\n\t\t\t  \t\t\t\t   // for vertical stereo we keep the full canvas height and handle the reflex areas while generating the color stops\r\n\r\n\t\tfor ( const channel of [0,1] ) {\r\n\t\t\tconst currGradient = this._gradients[ this._selectedGrads[ channel ] ],\r\n\t\t\t\t  colorStops   = currGradient.colorStops,\r\n\t\t\t\t  isHorizontal = currGradient.dir == 'h';\r\n\r\n\t\t\tlet grad;\r\n\r\n\t\t\tif ( _radial )\r\n\t\t\t\tgrad = _ctx.createRadialGradient( centerX, centerY, outerRadius, centerX, centerY, innerRadius - ( outerRadius - innerRadius ) * isDualVertical );\r\n\t\t\telse\r\n\t\t\t\tgrad = _ctx.createLinearGradient( ...( isHorizontal ? [ initialX, 0, initialX + analyzerWidth, 0 ] : [ 0, 0, 0, gradientHeight ] ) );\r\n\r\n\t\t\tif ( colorStops ) {\r\n\t\t\t\tconst dual = isDualVertical && ! this._splitGradient && ( ! isHorizontal || _radial );\r\n\r\n\t\t\t\tfor ( let channelArea = 0; channelArea < 1 + dual; channelArea++ ) {\r\n\t\t\t\t\tconst maxIndex = colorStops.length - 1;\r\n\r\n\t\t\t\t\tcolorStops.forEach( ( colorStop, index ) => {\r\n\t\t\t\t\t\tlet offset = colorStop.pos;\r\n\r\n\t\t\t\t\t\t// in dual mode (not split), use half the original offset for each channel\r\n\t\t\t\t\t\tif ( dual )\r\n\t\t\t\t\t\t\toffset /= 2;\r\n\r\n\t\t\t\t\t\t// constrain the offset within the useful analyzer areas (avoid reflex areas)\r\n\t\t\t\t\t\tif ( isDualVertical && ! isLumi && ! _radial && ! isHorizontal ) {\r\n\t\t\t\t\t\t\toffset *= analyzerRatio;\r\n\t\t\t\t\t\t\t// skip the first reflex area in split mode\r\n\t\t\t\t\t\t\tif ( ! dual && offset > .5 * analyzerRatio )\r\n\t\t\t\t\t\t\t\toffset += .5 * _reflexRatio;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// only for dual-vertical non-split gradient (creates full gradient on both halves of the canvas)\r\n\t\t\t\t\t\tif ( channelArea == 1 ) {\r\n\t\t\t\t\t\t\t// add colors in reverse order if radial or lumi are active\r\n\t\t\t\t\t\t\tif ( _radial || isLumi ) {\r\n\t\t\t\t\t\t\t\tconst revIndex = maxIndex - index;\r\n\t\t\t\t\t\t\t\tcolorStop = colorStops[ revIndex ];\r\n\t\t\t\t\t\t\t\toffset = 1 - colorStop.pos / 2;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t// if the first offset is not 0, create an additional color stop to prevent bleeding from the first channel\r\n\t\t\t\t\t\t\t\tif ( index == 0 && offset > 0 )\r\n\t\t\t\t\t\t\t\t\tgrad.addColorStop( .5, colorStop.color );\r\n\t\t\t\t\t\t\t\t// bump the offset to the second half of the gradient\r\n\t\t\t\t\t\t\t\toffset += .5;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// add gradient color stop\r\n\t\t\t\t\t\tgrad.addColorStop( offset, colorStop.color );\r\n\r\n\t\t\t\t\t\t// create additional color stop at the end of first channel to prevent bleeding\r\n\t\t\t\t\t\tif ( isDualVertical && index == maxIndex && offset < .5 )\r\n\t\t\t\t\t\t\tgrad.addColorStop( .5, colorStop.color );\r\n\t\t\t\t\t});\r\n\t\t\t\t} // for ( let channelArea = 0; channelArea < 1 + dual; channelArea++ )\r\n\t\t\t}\r\n\r\n\t\t\tthis._canvasGradients[ channel ] = grad;\r\n\t\t} // for ( const channel of [0,1] )\r\n\t}\r\n\r\n\t/**\r\n\t * Normalize a dB value in the [0;1] range\r\n\t */\r\n\t_normalizedB( value ) {\r\n\t\tconst isLinear   = this._linearAmplitude,\r\n\t\t\t  boost      = isLinear ? 1 / this._linearBoost : 1,\r\n\t\t\t  clamp      = ( val, min, max ) => val <= min ? min : val >= max ? max : val,\r\n\t\t\t  dBToLinear = val => 10 ** ( val / 20 );\r\n\r\n\t\tlet maxValue = this.maxDecibels,\r\n\t\t\tminValue = this.minDecibels;\r\n\r\n\t\tif ( isLinear ) {\r\n\t\t\tmaxValue = dBToLinear( maxValue );\r\n\t\t\tminValue = dBToLinear( minValue );\r\n\t\t\tvalue = dBToLinear( value ) ** boost;\r\n\t\t}\r\n\r\n\t\treturn clamp( ( value - minValue ) / ( maxValue - minValue ) ** boost, 0, 1 );\r\n\t}\r\n\r\n\t/**\r\n\t * Internal function to change canvas dimensions on demand\r\n\t */\r\n\t_setCanvas( reason ) {\r\n\t\tif ( ! this._ready )\r\n\t\t\treturn;\r\n\r\n\t\tconst { canvas, _ctx } = this,\r\n\t\t\t  canvasX    = this._scaleX.canvas,\r\n\t\t\t  pixelRatio = window.devicePixelRatio / ( this._loRes + 1 );\r\n\r\n\t\tlet screenWidth  = window.screen.width  * pixelRatio,\r\n\t\t\tscreenHeight = window.screen.height * pixelRatio;\r\n\r\n\t\t// Fix for iOS Safari - swap width and height when in landscape\r\n\t\tif ( Math.abs( window.orientation ) == 90 && screenWidth < screenHeight )\r\n\t\t\t[ screenWidth, screenHeight ] = [ screenHeight, screenWidth ];\r\n\r\n\t\tconst isFullscreen = this.isFullscreen,\r\n\t\t\t  isCanvasFs   = isFullscreen && this._fsEl == canvas,\r\n\t\t\t  newWidth     = isCanvasFs ? screenWidth  : ( this._width  || this._container.clientWidth  || this._defaultWidth  ) * pixelRatio | 0,\r\n\t\t\t  newHeight    = isCanvasFs ? screenHeight : ( this._height || this._container.clientHeight || this._defaultHeight ) * pixelRatio | 0;\r\n\r\n\t\t// set/update object properties\r\n\t\tthis._pixelRatio = pixelRatio;\r\n\t\tthis._fsWidth    = screenWidth;\r\n\t\tthis._fsHeight   = screenHeight;\r\n\r\n\t\t// if this is not the constructor call and canvas dimensions haven't changed, quit\r\n\t\tif ( reason != REASON_CREATE && canvas.width == newWidth && canvas.height == newHeight )\r\n\t\t\treturn;\r\n\r\n\t\t// apply new dimensions\r\n\t\tcanvas.width  = newWidth;\r\n\t\tcanvas.height = newHeight;\r\n\r\n\t\t// if not in overlay mode, paint the canvas black\r\n\t\tif ( ! this.overlay ) {\r\n\t\t\t_ctx.fillStyle = '#000';\r\n\t\t\t_ctx.fillRect( 0, 0, newWidth, newHeight );\r\n\t\t}\r\n\r\n\t\t// set lineJoin property for area fill mode (this is reset whenever the canvas size changes)\r\n\t\t_ctx.lineJoin = 'bevel';\r\n\r\n\t\t// update dimensions of the scale canvas\r\n\t\tcanvasX.width = newWidth;\r\n\t\tcanvasX.height = Math.max( 20 * pixelRatio, Math.min( newWidth, newHeight ) / 32 | 0 );\r\n\r\n\t\t// calculate bar positions and led options\r\n\t\tthis._calcBars();\r\n\r\n\t\t// (re)generate gradient\r\n\t\tthis._makeGrad();\r\n\r\n\t\t// detect fullscreen changes (for Safari)\r\n\t\tif ( this._fsStatus !== undefined && this._fsStatus !== isFullscreen )\r\n\t\t\treason = REASON_FSCHANGE;\r\n\t\tthis._fsStatus = isFullscreen;\r\n\r\n\t\t// call the callback function, if defined\r\n\t\tif ( this.onCanvasResize )\r\n\t\t\tthis.onCanvasResize( reason, this );\r\n\t}\r\n\r\n\t/**\r\n\t * Select a gradient for one or both channels\r\n\t *\r\n\t * @param {string} name gradient name\r\n\t * @param [{number}] desired channel (0 or 1) - if empty or invalid, sets both channels\r\n\t */\r\n\t_setGradient( name, channel ) {\r\n\t\tif ( ! this._gradients.hasOwnProperty( name ) )\r\n\t\t\tthrow new AudioMotionError( ERR_UNKNOWN_GRADIENT, name );\r\n\r\n\t\tif ( ! [0,1].includes( channel ) ) {\r\n\t\t\tthis._selectedGrads[1] = name;\r\n\t\t\tchannel = 0;\r\n\t\t}\r\n\r\n\t\tthis._selectedGrads[ channel ] = name;\r\n\t\tthis._makeGrad();\r\n\t}\r\n\r\n\t/**\r\n\t * Set object properties\r\n\t */\r\n\t_setProps( options, useDefaults ) {\r\n\t\t// callback functions properties\r\n\t\tconst callbacks = [ 'onCanvasDraw', 'onCanvasResize' ];\r\n\r\n\t\t// properties not in the defaults (`stereo` is deprecated)\r\n\t\tconst extraProps = [ 'gradientLeft', 'gradientRight', 'stereo' ];\r\n\r\n\t\t// build an array of valid properties; `start` is not an actual property and is handled after setting everything else\r\n\t\tconst validProps = Object.keys( DEFAULT_SETTINGS ).filter( e => e != 'start' ).concat( callbacks, extraProps );\r\n\r\n\t\tif ( useDefaults || options === undefined )\r\n\t\t\toptions = { ...DEFAULT_SETTINGS, ...options }; // merge options with defaults\r\n\r\n\t\tfor ( const prop of Object.keys( options ) ) {\r\n\t\t\tif ( callbacks.includes( prop ) && typeof options[ prop ] !== 'function' ) // check invalid callback\r\n\t\t\t\tthis[ prop ] = undefined;\r\n\t\t\telse if ( validProps.includes( prop ) ) // set only valid properties\r\n\t\t\t\tthis[ prop ] = options[ prop ];\r\n\t\t}\r\n\r\n\t\t// deprecated - move this to the constructor in the next major release (`start` should be constructor-specific)\r\n\t\tif ( options.start !== undefined )\r\n\t\t\tthis.toggleAnalyzer( options.start );\r\n\t}\r\n\r\n}\r\n\r\nexport { AudioMotionAnalyzer };\r\nexport default AudioMotionAnalyzer;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}